/* This file is automatically generated
   do not edit this file directly! */

#include "loadbalancing.h"
#include <caverif.h>
ca::ParameterInt param::JOBS("JOBS", "", ca::PARAMETER_MANDATORY);
void place_user_fn_119(ca::Context &ctx, ca::TokenList<int > &place);
class Tokens_117  : public ca::Binding {
	public:
	Tokens_117() {};
	Tokens_117(const Tokens_117 &t) {
		if (t.token_1005 != NULL) {
			token_1005 = new ca::Token<int >(t.token_1005->value);
		} else {
			token_1005 = NULL;
		}
		if (t.token_1007 != NULL) {
			token_1007 = new ca::Token<int >(t.token_1007->value);
		} else {
			token_1007 = NULL;
		}
	}
	Tokens_117& operator=(const Tokens_117 &t) {
		if (this != &t) {
			if (t.token_1005 != NULL) {
				delete token_1005;
				token_1005 = new ca::Token<int >(t.token_1005->value);
			} else {
				token_1005 = NULL;
			}
			if (t.token_1007 != NULL) {
				delete token_1007;
				token_1007 = new ca::Token<int >(t.token_1007->value);
			} else {
				token_1007 = NULL;
			}
		}
		return *this;
	}
	~Tokens_117() {
		if (token_1005 != NULL) {
			delete token_1005;
		}
		if (token_1007 != NULL) {
			delete token_1007;
		}
	}
	ca::Binding* copy() {
		Tokens_117 *t = new Tokens_117(*this);
		return t;
	}
	ca::Token<int > *token_1005;
	ca::Token<int > *token_1007;
};
class Transition_117  : public ca::TransitionDef {
	public:
	Transition_117() : ca::TransitionDef(117, "117", ca::TRANSITION_IMMEDIATE, 4) {
	}
	ca::FireResult full_fire(ca::ThreadBase *thread, ca::NetBase *net);
	ca::Binding* fire_phase1(ca::ThreadBase *thread, ca::NetBase *net);
	void fire_phase2(ca::ThreadBase *thread, ca::NetBase *net, ca::Binding *data);
	bool is_enable(ca::ThreadBase *thread, ca::NetBase *net);
	void pack_binding(ca::Packer &packer, ca::Binding *data);
	ca::Binding* unpack_binding(ca::Unpacker &unpacker);
	ca::FireResult full_fire_with_binding(ca::ThreadBase *thread, ca::NetBase *net, ca::Packer &__kaira__packer);
};
static Transition_117 transition_117;

class Tokens_116  : public ca::Binding {
	public:
	Tokens_116() {};
	Tokens_116(const Tokens_116 &t) {
		if (t.token_1001 != NULL) {
			token_1001 = new ca::Token<int >(t.token_1001->value);
		} else {
			token_1001 = NULL;
		}
	}
	Tokens_116& operator=(const Tokens_116 &t) {
		if (this != &t) {
			if (t.token_1001 != NULL) {
				delete token_1001;
				token_1001 = new ca::Token<int >(t.token_1001->value);
			} else {
				token_1001 = NULL;
			}
		}
		return *this;
	}
	~Tokens_116() {
		if (token_1001 != NULL) {
			delete token_1001;
		}
	}
	ca::Binding* copy() {
		Tokens_116 *t = new Tokens_116(*this);
		return t;
	}
	ca::Token<int > *token_1001;
};
class Transition_116  : public ca::TransitionDef {
	public:
	Transition_116() : ca::TransitionDef(116, "116", ca::TRANSITION_IMMEDIATE, 3) {
	}
	ca::FireResult full_fire(ca::ThreadBase *thread, ca::NetBase *net);
	ca::Binding* fire_phase1(ca::ThreadBase *thread, ca::NetBase *net);
	void fire_phase2(ca::ThreadBase *thread, ca::NetBase *net, ca::Binding *data);
	bool is_enable(ca::ThreadBase *thread, ca::NetBase *net);
	void pack_binding(ca::Packer &packer, ca::Binding *data);
	ca::Binding* unpack_binding(ca::Unpacker &unpacker);
	ca::FireResult full_fire_with_binding(ca::ThreadBase *thread, ca::NetBase *net, ca::Packer &__kaira__packer);
};
static Transition_116 transition_116;

class Vars_140 {
	public:
	Vars_140(ca::Context &ctx) : ctx(ctx) {
	}
	ca::Context &ctx;
};
void transition_user_fn_140(ca::Context &ctx, Vars_140 &var);
class Tokens_140  : public ca::Binding {
	public:
	Tokens_140() {};
	Tokens_140(const Tokens_140 &t) {
	}
	Tokens_140& operator=(const Tokens_140 &t) {
		if (this != &t) {
		}
		return *this;
	}
	~Tokens_140() {
	}
	ca::Binding* copy() {
		Tokens_140 *t = new Tokens_140(*this);
		return t;
	}
};
class Transition_140  : public ca::TransitionDef {
	public:
	Transition_140() : ca::TransitionDef(140, "140", ca::TRANSITION_NORMAL, 2) {
	}
	ca::FireResult full_fire(ca::ThreadBase *thread, ca::NetBase *net);
	ca::Binding* fire_phase1(ca::ThreadBase *thread, ca::NetBase *net);
	void fire_phase2(ca::ThreadBase *thread, ca::NetBase *net, ca::Binding *data);
	bool is_enable(ca::ThreadBase *thread, ca::NetBase *net);
	void pack_binding(ca::Packer &packer, ca::Binding *data);
	ca::Binding* unpack_binding(ca::Unpacker &unpacker);
	ca::FireResult full_fire_with_binding(ca::ThreadBase *thread, ca::NetBase *net, ca::Packer &__kaira__packer);
};
static Transition_140 transition_140;

class Tokens_131  : public ca::Binding {
	public:
	Tokens_131() {};
	Tokens_131(const Tokens_131 &t) {
		if (t.token_1013 != NULL) {
			token_1013 = new ca::Token<int >(t.token_1013->value);
		} else {
			token_1013 = NULL;
		}
	}
	Tokens_131& operator=(const Tokens_131 &t) {
		if (this != &t) {
			if (t.token_1013 != NULL) {
				delete token_1013;
				token_1013 = new ca::Token<int >(t.token_1013->value);
			} else {
				token_1013 = NULL;
			}
		}
		return *this;
	}
	~Tokens_131() {
		if (token_1013 != NULL) {
			delete token_1013;
		}
	}
	ca::Binding* copy() {
		Tokens_131 *t = new Tokens_131(*this);
		return t;
	}
	ca::Token<int > *token_1013;
};
class Transition_131  : public ca::TransitionDef {
	public:
	Transition_131() : ca::TransitionDef(131, "131", ca::TRANSITION_IMMEDIATE, 1) {
	}
	ca::FireResult full_fire(ca::ThreadBase *thread, ca::NetBase *net);
	ca::Binding* fire_phase1(ca::ThreadBase *thread, ca::NetBase *net);
	void fire_phase2(ca::ThreadBase *thread, ca::NetBase *net, ca::Binding *data);
	bool is_enable(ca::ThreadBase *thread, ca::NetBase *net);
	void pack_binding(ca::Packer &packer, ca::Binding *data);
	ca::Binding* unpack_binding(ca::Unpacker &unpacker);
	ca::FireResult full_fire_with_binding(ca::ThreadBase *thread, ca::NetBase *net, ca::Packer &__kaira__packer);
};
static Transition_131 transition_131;

class Net_101  : public cass::Net {
	public:
	ca::NetBase * copy() {
		Net_101 *net = new Net_101(*this);
		return net;
	}
	ca::Place<int > place_119;
	ca::Place<int > place_127;
	ca::Place<int > place_134;
	ca::Place<int > place_138;
	void write_reports_content(ca::ThreadBase *thread, ca::Output &output) {
		output.child("place");
		output.set("id", 119);
		{
			ca::Token<int > *t = place_119.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_119.begin());
			}
		}
		output.back();
		output.child("place");
		output.set("id", 127);
		{
			ca::Token<int > *t = place_127.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_127.begin());
			}
		}
		output.back();
		output.child("place");
		output.set("id", 134);
		{
			ca::Token<int > *t = place_134.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_134.begin());
			}
		}
		output.back();
		output.child("place");
		output.set("id", 138);
		{
			ca::Token<int > *t = place_138.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_138.begin());
			}
		}
		output.back();
	}
	void receive(ca::ThreadBase *__kaira__thread, int from_process, int place_pos, ca::Unpacker &unpacker) {
		switch(place_pos) {
		case 133:
		{
			ca::Token<int > *token = new ca::Token<int >();
			ca::unpack(unpacker, token->value);
			this->place_119.add_token(token);
			this->activate_transition_by_pos_id(1);
			this->activate_transition_by_pos_id(0);
		}
		break;
		case 136:
		{
			ca::Token<int > *token = new ca::Token<int >();
			ca::unpack(unpacker, token->value);
			this->place_134.add_token(token);
			this->activate_transition_by_pos_id(3);
		}
		break;
		case 139:
		{
			ca::Token<int > *token = new ca::Token<int >();
			ca::unpack(unpacker, token->value);
			this->place_138.add_token(token);
			this->activate_transition_by_pos_id(2);
		}
		break;
		case 132:
		{
			ca::Token<int > *token = new ca::Token<int >();
			ca::unpack(unpacker, token->value);
			this->place_127.add_token(token);
			this->activate_transition_by_pos_id(0);
		}
		break;
		}
	}
	cass::Net * copy_without_tokens() {
		Net_101 *net = new Net_101();
		return net;
	}
	void pack(ca::Packer &packer) {
		ca::pack(packer, place_119);
		ca::pack(packer, place_127);
		ca::pack(packer, place_134);
		ca::pack(packer, place_138);
	}
	void unpack(ca::Unpacker &unpacker) {
		ca::unpack(unpacker, place_119);
		ca::unpack(unpacker, place_127);
		ca::unpack(unpacker, place_134);
		ca::unpack(unpacker, place_138);
	}
	size_t get_token_count_in_place(int place_id) {
		if (place_id == 119) return this->place_119.size();
		if (place_id == 127) return this->place_127.size();
		if (place_id == 134) return this->place_134.size();
		if (place_id == 138) return this->place_138.size();
		return 0;
	}
};
ca::NetBase * spawn_101(ca::ThreadBase *__kaira__thread, ca::NetDef *__kaira__def) {
	Net_101 *__kaira__net = new Net_101();
	ca::Context ctx(__kaira__thread, __kaira__net);
	int __kaira__pid = __kaira__thread->get_process_id();
	std::vector<int> __kaira__area_144 = ctx.all_processes();
	std::vector<int> __kaira__area_145 = ctx.all_processes();
	if (std::find(__kaira__area_145.begin(), __kaira__area_145.end(), __kaira__pid) != __kaira__area_145.end()) {
		{
			ca::TokenList<int > __kaira__list;
			place_user_fn_119(ctx, __kaira__list);
			__kaira__net->place_119.overtake(__kaira__list);
		}
	}
	if (std::find(__kaira__area_144.begin(), __kaira__area_144.end(), __kaira__pid) != __kaira__area_144.end()) {
		__kaira__net->place_134.add(down(ctx));
		__kaira__net->place_134.add(up(ctx));
	}
	return __kaira__net;
}
ca::FireResult Transition_117::full_fire(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_119.size() < 1) return ca::NOT_ENABLED;
	if (__kaira__n->place_127.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=130 uid=1005 expr=job
	ca::Token < int > *__kaira__token_1005;
	__kaira__token_1005 = __kaira__n->place_119.begin();
	int &job = __kaira__token_1005->value;
	// Inscription id=130 uid=1007 expr=neighbor
	ca::Token < int > *__kaira__token_1007;
	__kaira__token_1007 = __kaira__n->place_127.begin();
	int &neighbor = __kaira__token_1007->value;
	{
		size_t size = __kaira__n->place_119.size();
		if (!(size > 2)) {
			return ca::NOT_ENABLED;
		}
	}
	{
		{
			__kaira__n->place_119.remove(__kaira__token_1005);
			__kaira__n->place_127.remove(__kaira__token_1007);
		}
		__kaira__n->activate_transition_by_pos_id(0);
		if (neighbor == __kaira__thread->get_process_id()) {
			__kaira__n->place_119.add(job);
			__kaira__n->activate_transition_by_pos_id(1);
			__kaira__n->activate_transition_by_pos_id(0);
		} else {
			int __kaira__target = neighbor;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (job));
				__kaira__thread->send(__kaira__target, __kaira__n, 133, 1, __kaira__packer);
			}
			if (neighbor == __kaira__thread->get_process_id()) {
				__kaira__n->place_134.add(ctx.process_id());
				__kaira__n->activate_transition_by_pos_id(3);
		} else {
			int __kaira__target = neighbor;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (ctx.process_id()));
				__kaira__thread->send(__kaira__target, __kaira__n, 136, 1, __kaira__packer);
			}
			delete __kaira__token_1005;
			delete __kaira__token_1007;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::Binding* Transition_117::fire_phase1(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_119.size() < 1) return NULL;
	if (__kaira__n->place_127.size() < 1) return NULL;
	// Inscription id=130 uid=1005 expr=job
	ca::Token < int > *__kaira__token_1005;
	__kaira__token_1005 = __kaira__n->place_119.begin();
	int &job = __kaira__token_1005->value;
	// Inscription id=130 uid=1007 expr=neighbor
	ca::Token < int > *__kaira__token_1007;
	__kaira__token_1007 = __kaira__n->place_127.begin();
	int &neighbor = __kaira__token_1007->value;
	{
		size_t size = __kaira__n->place_119.size();
		if (!(size > 2)) {
			return NULL;
		}
	}
	{
		{
			__kaira__n->place_119.remove(__kaira__token_1005);
			__kaira__n->place_127.remove(__kaira__token_1007);
		}
		Tokens_117 *__kaira__tokens = new Tokens_117();
		__kaira__tokens->token_1005 = __kaira__token_1005;
		__kaira__tokens->token_1007 = __kaira__token_1007;
		return __kaira__tokens;
	}
	return NULL;
}
void Transition_117::fire_phase2(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Binding *__kaira__binding)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	Tokens_117 *__kaira__tokens = static_cast<Tokens_117*>(__kaira__binding);
	ca::Token<int > *__kaira__token_1005 = __kaira__tokens->token_1005;
	ca::Token<int > *__kaira__token_1007 = __kaira__tokens->token_1007;
	int &job = __kaira__token_1005->value;
	int &neighbor = __kaira__token_1007->value;
	__kaira__n->activate_transition_by_pos_id(0);
	if (neighbor == __kaira__thread->get_process_id()) {
		__kaira__n->place_119.add(job);
		__kaira__n->activate_transition_by_pos_id(1);
		__kaira__n->activate_transition_by_pos_id(0);
} else {
	int __kaira__target = neighbor;
		ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
		ca::pack(__kaira__packer, (job));
		__kaira__thread->send(__kaira__target, __kaira__n, 133, 1, __kaira__packer);
	}
	if (neighbor == __kaira__thread->get_process_id()) {
		__kaira__n->place_134.add(ctx.process_id());
		__kaira__n->activate_transition_by_pos_id(3);
} else {
	int __kaira__target = neighbor;
		ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
		ca::pack(__kaira__packer, (ctx.process_id()));
		__kaira__thread->send(__kaira__target, __kaira__n, 136, 1, __kaira__packer);
	}
	delete __kaira__binding;
}
bool Transition_117::is_enable(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_119.size() < 1) return false;
	if (__kaira__n->place_127.size() < 1) return false;
	// Inscription id=130 uid=1005 expr=job
	ca::Token < int > *__kaira__token_1005;
	__kaira__token_1005 = __kaira__n->place_119.begin();
	int &job = __kaira__token_1005->value;
	// Inscription id=130 uid=1007 expr=neighbor
	ca::Token < int > *__kaira__token_1007;
	__kaira__token_1007 = __kaira__n->place_127.begin();
	int &neighbor = __kaira__token_1007->value;
	{
		size_t size = __kaira__n->place_119.size();
		if (!(size > 2)) {
			return false;
		}
	}
	{
		return true;
	}
	return false;
}
void Transition_117::pack_binding(ca::Packer &packer, ca::Binding *binding)
{
	Tokens_117 *tokens = static_cast<Tokens_117*>(binding);
	ca::pack(packer, tokens->token_1005->value);
	ca::pack(packer, tokens->token_1007->value);
}
ca::Binding* Transition_117::unpack_binding(ca::Unpacker &unpacker)
{
	Tokens_117 *tokens = new Tokens_117;
	tokens->token_1005 = new ca::Token<int >;
	ca::unpack(unpacker, tokens->token_1005->value);
	tokens->token_1007 = new ca::Token<int >;
	ca::unpack(unpacker, tokens->token_1007->value);
	return tokens;
}
ca::FireResult Transition_117::full_fire_with_binding(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Packer &__kaira__packer)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_119.size() < 1) return ca::NOT_ENABLED;
	if (__kaira__n->place_127.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=130 uid=1005 expr=job
	ca::Token < int > *__kaira__token_1005;
	__kaira__token_1005 = __kaira__n->place_119.begin();
	int &job = __kaira__token_1005->value;
	// Inscription id=130 uid=1007 expr=neighbor
	ca::Token < int > *__kaira__token_1007;
	__kaira__token_1007 = __kaira__n->place_127.begin();
	int &neighbor = __kaira__token_1007->value;
	{
		size_t size = __kaira__n->place_119.size();
		if (!(size > 2)) {
			return ca::NOT_ENABLED;
		}
	}
	{
		ca::pack(__kaira__packer, __kaira__token_1005->value);
		ca::pack(__kaira__packer, __kaira__token_1007->value);
		{
			__kaira__n->place_119.remove(__kaira__token_1005);
			__kaira__n->place_127.remove(__kaira__token_1007);
		}
		__kaira__n->activate_transition_by_pos_id(0);
		if (neighbor == __kaira__thread->get_process_id()) {
			__kaira__n->place_119.add(job);
			__kaira__n->activate_transition_by_pos_id(1);
			__kaira__n->activate_transition_by_pos_id(0);
		} else {
			int __kaira__target = neighbor;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (job));
				__kaira__thread->send(__kaira__target, __kaira__n, 133, 1, __kaira__packer);
			}
			if (neighbor == __kaira__thread->get_process_id()) {
				__kaira__n->place_134.add(ctx.process_id());
				__kaira__n->activate_transition_by_pos_id(3);
		} else {
			int __kaira__target = neighbor;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (ctx.process_id()));
				__kaira__thread->send(__kaira__target, __kaira__n, 136, 1, __kaira__packer);
			}
			delete __kaira__token_1005;
			delete __kaira__token_1007;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::FireResult Transition_116::full_fire(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_119.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=120 uid=1001 expr=job
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_119.begin();
	int &job = __kaira__token_1001->value;
	{
		{
			__kaira__n->place_119.remove(__kaira__token_1001);
		}
		__kaira__n->activate_transition_by_pos_id(1);
		if (0 == __kaira__thread->get_process_id()) {
			__kaira__n->place_138.add(job);
			__kaira__n->activate_transition_by_pos_id(2);
		} else {
			int __kaira__target = 0;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (job));
				__kaira__thread->send(__kaira__target, __kaira__n, 139, 1, __kaira__packer);
			}
			delete __kaira__token_1001;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::Binding* Transition_116::fire_phase1(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_119.size() < 1) return NULL;
	// Inscription id=120 uid=1001 expr=job
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_119.begin();
	int &job = __kaira__token_1001->value;
	{
		{
			__kaira__n->place_119.remove(__kaira__token_1001);
		}
		Tokens_116 *__kaira__tokens = new Tokens_116();
		__kaira__tokens->token_1001 = __kaira__token_1001;
		return __kaira__tokens;
	}
	return NULL;
}
void Transition_116::fire_phase2(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Binding *__kaira__binding)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	Tokens_116 *__kaira__tokens = static_cast<Tokens_116*>(__kaira__binding);
	ca::Token<int > *__kaira__token_1001 = __kaira__tokens->token_1001;
	int &job = __kaira__token_1001->value;
	__kaira__n->activate_transition_by_pos_id(1);
	if (0 == __kaira__thread->get_process_id()) {
		__kaira__n->place_138.add(job);
		__kaira__n->activate_transition_by_pos_id(2);
} else {
	int __kaira__target = 0;
		ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
		ca::pack(__kaira__packer, (job));
		__kaira__thread->send(__kaira__target, __kaira__n, 139, 1, __kaira__packer);
	}
	delete __kaira__binding;
}
bool Transition_116::is_enable(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_119.size() < 1) return false;
	// Inscription id=120 uid=1001 expr=job
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_119.begin();
	int &job = __kaira__token_1001->value;
	{
		return true;
	}
	return false;
}
void Transition_116::pack_binding(ca::Packer &packer, ca::Binding *binding)
{
	Tokens_116 *tokens = static_cast<Tokens_116*>(binding);
	ca::pack(packer, tokens->token_1001->value);
}
ca::Binding* Transition_116::unpack_binding(ca::Unpacker &unpacker)
{
	Tokens_116 *tokens = new Tokens_116;
	tokens->token_1001 = new ca::Token<int >;
	ca::unpack(unpacker, tokens->token_1001->value);
	return tokens;
}
ca::FireResult Transition_116::full_fire_with_binding(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Packer &__kaira__packer)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_119.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=120 uid=1001 expr=job
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_119.begin();
	int &job = __kaira__token_1001->value;
	{
		ca::pack(__kaira__packer, __kaira__token_1001->value);
		{
			__kaira__n->place_119.remove(__kaira__token_1001);
		}
		__kaira__n->activate_transition_by_pos_id(1);
		if (0 == __kaira__thread->get_process_id()) {
			__kaira__n->place_138.add(job);
			__kaira__n->activate_transition_by_pos_id(2);
		} else {
			int __kaira__target = 0;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (job));
				__kaira__thread->send(__kaira__target, __kaira__n, 139, 1, __kaira__packer);
			}
			delete __kaira__token_1001;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::FireResult Transition_140::full_fire(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	{
		size_t size = __kaira__n->place_138.size();
		if (!(size == param::JOBS() * ctx.process_count())) {
			return ca::NOT_ENABLED;
		}
	}
	{
		{
		}
		__kaira__n->activate_transition_by_pos_id(2);
		Vars_140 __kaira__vars(ctx);
		transition_user_fn_140(ctx, __kaira__vars);
		return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::Binding* Transition_140::fire_phase1(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	{
		size_t size = __kaira__n->place_138.size();
		if (!(size == param::JOBS() * ctx.process_count())) {
			return NULL;
		}
	}
	{
		{
		}
		Tokens_140 *__kaira__tokens = new Tokens_140();
		return __kaira__tokens;
	}
	return NULL;
}
void Transition_140::fire_phase2(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Binding *__kaira__binding)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	Tokens_140 *__kaira__tokens = static_cast<Tokens_140*>(__kaira__binding);
	__kaira__n->activate_transition_by_pos_id(2);
	Vars_140 __kaira__vars(ctx);
	transition_user_fn_140(ctx, __kaira__vars);
	delete __kaira__binding;
}
bool Transition_140::is_enable(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	{
		size_t size = __kaira__n->place_138.size();
		if (!(size == param::JOBS() * ctx.process_count())) {
			return false;
		}
	}
	{
		return true;
	}
	return false;
}
void Transition_140::pack_binding(ca::Packer &packer, ca::Binding *binding)
{
	Tokens_140 *tokens = static_cast<Tokens_140*>(binding);
}
ca::Binding* Transition_140::unpack_binding(ca::Unpacker &unpacker)
{
	Tokens_140 *tokens = new Tokens_140;
	return tokens;
}
ca::FireResult Transition_140::full_fire_with_binding(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Packer &__kaira__packer)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	{
		size_t size = __kaira__n->place_138.size();
		if (!(size == param::JOBS() * ctx.process_count())) {
			return ca::NOT_ENABLED;
		}
	}
	{
		{
		}
		__kaira__n->activate_transition_by_pos_id(2);
		Vars_140 __kaira__vars(ctx);
		transition_user_fn_140(ctx, __kaira__vars);
		return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::FireResult Transition_131::full_fire(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_134.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=135 uid=1013 expr=neighbor
	ca::Token < int > *__kaira__token_1013;
	__kaira__token_1013 = __kaira__n->place_134.begin();
	int &neighbor = __kaira__token_1013->value;
	{
		{
			__kaira__n->place_134.remove(__kaira__token_1013);
		}
		__kaira__n->activate_transition_by_pos_id(3);
		if (neighbor == __kaira__thread->get_process_id()) {
			__kaira__n->place_127.add(ctx.process_id());
			__kaira__n->activate_transition_by_pos_id(0);
		} else {
			int __kaira__target = neighbor;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (ctx.process_id()));
				__kaira__thread->send(__kaira__target, __kaira__n, 132, 1, __kaira__packer);
			}
			delete __kaira__token_1013;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::Binding* Transition_131::fire_phase1(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_134.size() < 1) return NULL;
	// Inscription id=135 uid=1013 expr=neighbor
	ca::Token < int > *__kaira__token_1013;
	__kaira__token_1013 = __kaira__n->place_134.begin();
	int &neighbor = __kaira__token_1013->value;
	{
		{
			__kaira__n->place_134.remove(__kaira__token_1013);
		}
		Tokens_131 *__kaira__tokens = new Tokens_131();
		__kaira__tokens->token_1013 = __kaira__token_1013;
		return __kaira__tokens;
	}
	return NULL;
}
void Transition_131::fire_phase2(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Binding *__kaira__binding)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	Tokens_131 *__kaira__tokens = static_cast<Tokens_131*>(__kaira__binding);
	ca::Token<int > *__kaira__token_1013 = __kaira__tokens->token_1013;
	int &neighbor = __kaira__token_1013->value;
	__kaira__n->activate_transition_by_pos_id(3);
	if (neighbor == __kaira__thread->get_process_id()) {
		__kaira__n->place_127.add(ctx.process_id());
		__kaira__n->activate_transition_by_pos_id(0);
} else {
	int __kaira__target = neighbor;
		ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
		ca::pack(__kaira__packer, (ctx.process_id()));
		__kaira__thread->send(__kaira__target, __kaira__n, 132, 1, __kaira__packer);
	}
	delete __kaira__binding;
}
bool Transition_131::is_enable(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_134.size() < 1) return false;
	// Inscription id=135 uid=1013 expr=neighbor
	ca::Token < int > *__kaira__token_1013;
	__kaira__token_1013 = __kaira__n->place_134.begin();
	int &neighbor = __kaira__token_1013->value;
	{
		return true;
	}
	return false;
}
void Transition_131::pack_binding(ca::Packer &packer, ca::Binding *binding)
{
	Tokens_131 *tokens = static_cast<Tokens_131*>(binding);
	ca::pack(packer, tokens->token_1013->value);
}
ca::Binding* Transition_131::unpack_binding(ca::Unpacker &unpacker)
{
	Tokens_131 *tokens = new Tokens_131;
	tokens->token_1013 = new ca::Token<int >;
	ca::unpack(unpacker, tokens->token_1013->value);
	return tokens;
}
ca::FireResult Transition_131::full_fire_with_binding(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Packer &__kaira__packer)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_134.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=135 uid=1013 expr=neighbor
	ca::Token < int > *__kaira__token_1013;
	__kaira__token_1013 = __kaira__n->place_134.begin();
	int &neighbor = __kaira__token_1013->value;
	{
		ca::pack(__kaira__packer, __kaira__token_1013->value);
		{
			__kaira__n->place_134.remove(__kaira__token_1013);
		}
		__kaira__n->activate_transition_by_pos_id(3);
		if (neighbor == __kaira__thread->get_process_id()) {
			__kaira__n->place_127.add(ctx.process_id());
			__kaira__n->activate_transition_by_pos_id(0);
		} else {
			int __kaira__target = neighbor;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (ctx.process_id()));
				__kaira__thread->send(__kaira__target, __kaira__n, 132, 1, __kaira__packer);
			}
			delete __kaira__token_1013;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
class VerifConfiguration : public cass::VerifConfiguration {
public:
VerifConfiguration()
{
	int transitions[] = {117, 116, 140, 131};
	for (int i = 0; i < 4; i++)
	{
		ignored_transitions.insert(transitions[i]);
	}
}
bool is_dependent(const cass::Action &a1, const cass::Action &a2, const std::vector<int> &marking)
{
	cass::VerifThread thread(a1.process);
	ca::Context ctx(&thread, NULL);
	if (a1.type == cass::ActionFire && a2.type == cass::ActionFire) {
	}
	if (a1.process != a2.process) {
		return false;
	}
	if (a1.type == cass::ActionFire && a2.type == cass::ActionFire) {
		if (a1.data.fire.transition_def->get_id() == a2.data.fire.transition_def->get_id()) {
			fprintf(stderr, "Internal error - The same transitions in POR.\n");
			abort();
		}
		switch (a1.data.fire.transition_def->get_id()) {
			case 117:
			{
				switch (a2.data.fire.transition_def->get_id()) {
					case 116:
					{
						return true; // Transitions have different priority
						break;
					}

					case 140:
					{
						return true; // Transitions have different priority
						break;
					}

					case 131:
					{
						return true; // Transitions have different priority
						break;
					}

					default:
					fprintf(stderr, "Internal error");
					abort();
				}
				break;
			}

			case 116:
			{
				switch (a2.data.fire.transition_def->get_id()) {
					case 117:
					{
						return true; // Transitions have different priority
						break;
					}

					case 140:
					{
						return true; // Transitions have different priority
						break;
					}

					case 131:
					{
						return true; // Transitions have different priority
						break;
					}

					default:
					fprintf(stderr, "Internal error");
					abort();
				}
				break;
			}

			case 140:
			{
				switch (a2.data.fire.transition_def->get_id()) {
					case 117:
					{
						return true; // Transitions have different priority
						break;
					}

					case 116:
					{
						return true; // Transitions have different priority
						break;
					}

					case 131:
					{
						return true; // Transitions have different priority
						break;
					}

					default:
					fprintf(stderr, "Internal error");
					abort();
				}
				break;
			}

			case 131:
			{
				switch (a2.data.fire.transition_def->get_id()) {
					case 117:
					{
						return true; // Transitions have different priority
						break;
					}

					case 116:
					{
						return true; // Transitions have different priority
						break;
					}

					case 140:
					{
						return true; // Transitions have different priority
						break;
					}

					default:
					fprintf(stderr, "Internal error");
					abort();
				}
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
	}
	if (a1.type == cass::ActionFire && a2.type == cass::ActionReceive) {
		switch (a2.data.receive.edge_id) {
			case 133:
			{
				// t 117 --> p 119
				int edge_priority = 0;
				if (is_enabled(116, a1.process, marking, 119)) edge_priority = 3;
				if (is_enabled(117, a1.process, marking, 119)) edge_priority = 4;
				if (edge_priority > 4 && 117 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 3 && 116 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 2 && 140 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 1 && 131 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 136:
			{
				// t 117 --> p 134
				int edge_priority = 0;
				if (is_enabled(131, a1.process, marking, 134)) edge_priority = 1;
				if (edge_priority > 4 && 117 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 3 && 116 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 2 && 140 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 1 && 131 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 139:
			{
				// t 116 --> p 138
				int edge_priority = 0;
				if (is_enabled(140, a1.process, marking, 138)) edge_priority = 2;
				if (edge_priority > 4 && 117 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 3 && 116 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 2 && 140 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 1 && 131 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 132:
			{
				// t 131 --> p 127
				int edge_priority = 0;
				if (is_enabled(117, a1.process, marking, 127)) edge_priority = 4;
				if (edge_priority > 4 && 117 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 3 && 116 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 2 && 140 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 1 && 131 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
		switch (a1.data.fire.transition_def->get_id()) {
			case 117:
			{
				// t 117 --> p 119
				if (a2.data.receive.edge_id == 133) {
					return true;
				}
				// t 117 --> p 134
				if (a2.data.receive.edge_id == 136) {
					return true;
				}
				return false;
				break;
			}

			case 116:
			{
				// t 116 --> p 138
				if (a2.data.receive.edge_id == 139) {
					if (a1.process != (0)) {
						return false;
					}
					return true;
				}
				return false;
				break;
			}

			case 140:
			{
				return false;
				break;
			}

			case 131:
			{
				// t 131 --> p 127
				if (a2.data.receive.edge_id == 132) {
					return true;
				}
				return false;
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
	}
	if (a1.type == cass::ActionReceive && a2.type == cass::ActionFire) {
		switch (a1.data.receive.edge_id) {
			case 133:
			{
				// t 117 --> p 119
				int edge_priority = 0;
				if (is_enabled(116, a1.process, marking, 119)) edge_priority = 3;
				if (is_enabled(117, a1.process, marking, 119)) edge_priority = 4;
				if (edge_priority > 4 && 117 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 3 && 116 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 2 && 140 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 1 && 131 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 136:
			{
				// t 117 --> p 134
				int edge_priority = 0;
				if (is_enabled(131, a1.process, marking, 134)) edge_priority = 1;
				if (edge_priority > 4 && 117 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 3 && 116 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 2 && 140 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 1 && 131 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 139:
			{
				// t 116 --> p 138
				int edge_priority = 0;
				if (is_enabled(140, a1.process, marking, 138)) edge_priority = 2;
				if (edge_priority > 4 && 117 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 3 && 116 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 2 && 140 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 1 && 131 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 132:
			{
				// t 131 --> p 127
				int edge_priority = 0;
				if (is_enabled(117, a1.process, marking, 127)) edge_priority = 4;
				if (edge_priority > 4 && 117 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 3 && 116 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 2 && 140 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 1 && 131 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
		switch (a2.data.fire.transition_def->get_id()) {
			case 117:
			{
				// t 117 --> p 119
				if (a1.data.receive.edge_id == 133) {
					return true;
				}
				// t 117 --> p 134
				if (a1.data.receive.edge_id == 136) {
					return true;
				}
				return false;
				break;
			}

			case 116:
			{
				// t 116 --> p 138
				if (a1.data.receive.edge_id == 139) {
					if (a1.process != (0)) {
						return false;
					}
					return true;
				}
				return false;
				break;
			}

			case 140:
			{
				return false;
				break;
			}

			case 131:
			{
				// t 131 --> p 127
				if (a1.data.receive.edge_id == 132) {
					return true;
				}
				return false;
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
	}
	if (a1.type == cass::ActionReceive && a2.type == cass::ActionReceive) {
		if (a1.data.receive.edge_id == a2.data.receive.edge_id &&a1.data.receive.source == a2.data.receive.source) {
			fprintf(stderr, "Internal error - The same receive actions in POR");
			abort();
		}
		switch (a1.data.receive.edge_id) {
			case 133: // t 117 --> p 119
			return false;
			case 136: // t 117 --> p 134
			return false;
			case 139: // t 116 --> p 138
			return false;
			case 132: // t 131 --> p 127
			return false;
			default: return false;
		}
	}
}
bool is_visible(const cass::Action &action)
{
	if (action.type == cass::ActionFire) {
	}
	return false;
}
bool compare(const cass::Arc &arc1, const cass::Arc &arc2)
{
	if (arc1.nni->data.fire.transition_id == arc2.nni->data.fire.transition_id) {
		switch (arc1.nni->data.fire.transition_id) {
		}
	} else {
		return arc1.nni->data.fire.transition_id < arc2.nni->data.fire.transition_id;
	}
}
void compute_successors(const cass::Action &a,std::deque<cass::Action> &queue,cass::ActionSet &processed,const std::vector<bool> &receive_blocked,const std::vector<int> &enabled_priorities,std::vector<int> &marking,const cass::ActionSet &ample)
{
	cass::Action action;
	cass::VerifThread thread(a.process);
	ca::Context ctx(&thread, NULL);
	switch (a.type) {
		case cass::ActionFire:
		switch (a.data.fire.transition_def->get_id()) {
			case 117:
			{
				const cass::Action &__kaira__a = a;
				// place 119
				// there is 4 places, place 119 is on position 0.
				marking[4 * __kaira__a.process + 0]++;
				if (is_enabled(116, __kaira__a.process, marking, -1)) {
					action.type = cass::ActionFire;
					action.process = __kaira__a.process;
					action.data.fire.transition_def = &transition_116;
					if (enabled_priorities[action.process] <= transition_116.get_priority() && processed.find(action) == processed.end()) {
						queue.push_back(action);
						processed.insert(action);
					}
				}
				for (int __kaira__p = 0; __kaira__p < ca::process_count; __kaira__p++)
				{
					if (__kaira__p != __kaira__a.process) {
						action.type = cass::ActionReceive;
						action.process = __kaira__p;
						action.data.receive.source = a.process;
						action.data.receive.edge_id = 133;
						if (!receive_blocked[action.process * ca::process_count + __kaira__a.process] && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
				}
				// place 134
				// there is 4 places, place 134 is on position 2.
				marking[4 * __kaira__a.process + 2]++;
				if (is_enabled(131, __kaira__a.process, marking, -1)) {
					action.type = cass::ActionFire;
					action.process = __kaira__a.process;
					action.data.fire.transition_def = &transition_131;
					if (enabled_priorities[action.process] <= transition_131.get_priority() && processed.find(action) == processed.end()) {
						queue.push_back(action);
						processed.insert(action);
					}
				}
				for (int __kaira__p = 0; __kaira__p < ca::process_count; __kaira__p++)
				{
					if (__kaira__p != __kaira__a.process) {
						action.type = cass::ActionReceive;
						action.process = __kaira__p;
						action.data.receive.source = a.process;
						action.data.receive.edge_id = 136;
						if (!receive_blocked[action.process * ca::process_count + __kaira__a.process] && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
				}
				// transition has lower priority
				if (is_enabled(116, __kaira__a.process, marking, -1)) {
					action.type = cass::ActionFire;
					action.process = __kaira__a.process;
					action.data.fire.transition_def = &transition_116;
					if (enabled_priorities[action.process] <= transition_116.get_priority() && processed.find(action) == processed.end()) {
						queue.push_back(action);
						processed.insert(action);
					}
				}
				// transition has lower priority
				if (is_enabled(140, __kaira__a.process, marking, -1)) {
					action.type = cass::ActionFire;
					action.process = __kaira__a.process;
					action.data.fire.transition_def = &transition_140;
					if (enabled_priorities[action.process] <= transition_140.get_priority() && processed.find(action) == processed.end()) {
						queue.push_back(action);
						processed.insert(action);
					}
				}
				// transition has lower priority
				if (is_enabled(131, __kaira__a.process, marking, -1)) {
					action.type = cass::ActionFire;
					action.process = __kaira__a.process;
					action.data.fire.transition_def = &transition_131;
					if (enabled_priorities[action.process] <= transition_131.get_priority() && processed.find(action) == processed.end()) {
						queue.push_back(action);
						processed.insert(action);
					}
				}
				return;
				break;
			}

			case 116:
			{
				const cass::Action &__kaira__a = a;
				// place 138
				{
					int __kaira__target = 0;
					if (__kaira__a.process == __kaira__target) {
						// there is 4 places, place 138 is on position 3.
						marking[4 * __kaira__a.process + 3]++;
						if (is_enabled(140, __kaira__a.process, marking, -1)) {
							action.type = cass::ActionFire;
							action.process = __kaira__a.process;
							action.data.fire.transition_def = &transition_140;
							if (enabled_priorities[action.process] <= transition_140.get_priority() && processed.find(action) == processed.end()) {
								queue.push_back(action);
								processed.insert(action);
							}
						}
					} else {
						action.type = cass::ActionReceive;
						action.process = __kaira__target;
						action.data.receive.source = a.process;
						action.data.receive.edge_id = 139;
						if (!receive_blocked[action.process * ca::process_count + __kaira__a.process] && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
				}
				// transition has lower priority
				if (is_enabled(140, __kaira__a.process, marking, -1)) {
					action.type = cass::ActionFire;
					action.process = __kaira__a.process;
					action.data.fire.transition_def = &transition_140;
					if (enabled_priorities[action.process] <= transition_140.get_priority() && processed.find(action) == processed.end()) {
						queue.push_back(action);
						processed.insert(action);
					}
				}
				// transition has lower priority
				if (is_enabled(131, __kaira__a.process, marking, -1)) {
					action.type = cass::ActionFire;
					action.process = __kaira__a.process;
					action.data.fire.transition_def = &transition_131;
					if (enabled_priorities[action.process] <= transition_131.get_priority() && processed.find(action) == processed.end()) {
						queue.push_back(action);
						processed.insert(action);
					}
				}
				return;
				break;
			}

			case 140:
			{
				const cass::Action &__kaira__a = a;
				// transition has lower priority
				if (is_enabled(131, __kaira__a.process, marking, -1)) {
					action.type = cass::ActionFire;
					action.process = __kaira__a.process;
					action.data.fire.transition_def = &transition_131;
					if (enabled_priorities[action.process] <= transition_131.get_priority() && processed.find(action) == processed.end()) {
						queue.push_back(action);
						processed.insert(action);
					}
				}
				return;
				break;
			}

			case 131:
			{
				const cass::Action &__kaira__a = a;
				// place 127
				// there is 4 places, place 127 is on position 1.
				marking[4 * __kaira__a.process + 1]++;
				if (is_enabled(117, __kaira__a.process, marking, -1)) {
					action.type = cass::ActionFire;
					action.process = __kaira__a.process;
					action.data.fire.transition_def = &transition_117;
					if (enabled_priorities[action.process] <= transition_117.get_priority() && processed.find(action) == processed.end()) {
						queue.push_back(action);
						processed.insert(action);
					}
				}
				for (int __kaira__p = 0; __kaira__p < ca::process_count; __kaira__p++)
				{
					if (__kaira__p != __kaira__a.process) {
						action.type = cass::ActionReceive;
						action.process = __kaira__p;
						action.data.receive.source = a.process;
						action.data.receive.edge_id = 132;
						if (!receive_blocked[action.process * ca::process_count + __kaira__a.process] && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
				}
				return;
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
		case cass::ActionReceive:
		{
			switch (a.data.receive.edge_id) {
				case 133: // t 117 --> p 119
				{
					const cass::Action &__kaira__a = a;
					// there is 4 places, place 119 is on position 0.
					marking[4 * __kaira__a.process + 0]++;
					if (is_enabled(117, __kaira__a.process, marking, -1)) {
						action.type = cass::ActionFire;
						action.process = __kaira__a.process;
						action.data.fire.transition_def = &transition_117;
						if (enabled_priorities[action.process] <= transition_117.get_priority() && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
					if (is_enabled(116, __kaira__a.process, marking, -1)) {
						action.type = cass::ActionFire;
						action.process = __kaira__a.process;
						action.data.fire.transition_def = &transition_116;
						if (enabled_priorities[action.process] <= transition_116.get_priority() && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
					return;
				}
				case 136: // t 117 --> p 134
				{
					const cass::Action &__kaira__a = a;
					// there is 4 places, place 134 is on position 2.
					marking[4 * __kaira__a.process + 2]++;
					if (is_enabled(131, __kaira__a.process, marking, -1)) {
						action.type = cass::ActionFire;
						action.process = __kaira__a.process;
						action.data.fire.transition_def = &transition_131;
						if (enabled_priorities[action.process] <= transition_131.get_priority() && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
					return;
				}
				case 139: // t 116 --> p 138
				{
					const cass::Action &__kaira__a = a;
					// there is 4 places, place 138 is on position 3.
					marking[4 * __kaira__a.process + 3]++;
					if (is_enabled(140, __kaira__a.process, marking, -1)) {
						action.type = cass::ActionFire;
						action.process = __kaira__a.process;
						action.data.fire.transition_def = &transition_140;
						if (enabled_priorities[action.process] <= transition_140.get_priority() && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
					return;
				}
				case 132: // t 131 --> p 127
				{
					const cass::Action &__kaira__a = a;
					// there is 4 places, place 127 is on position 1.
					marking[4 * __kaira__a.process + 1]++;
					if (is_enabled(117, __kaira__a.process, marking, -1)) {
						action.type = cass::ActionFire;
						action.process = __kaira__a.process;
						action.data.fire.transition_def = &transition_117;
						if (enabled_priorities[action.process] <= transition_117.get_priority() && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
					return;
				}
			}
			return;
		}
	}
}
std::vector<int> get_marking(cass::State *s) {
	std::vector<int> marking;
	marking.resize(4 * ca::process_count);
	for (int p = 0; p < ca::process_count; p++) {
		Net_101 *n = (Net_101 *) s->get_net(p);
		marking[p * 4 + 0] = n->get_token_count_in_place(119);
		marking[p * 4 + 1] = n->get_token_count_in_place(127);
		marking[p * 4 + 2] = n->get_token_count_in_place(134);
		marking[p * 4 + 3] = n->get_token_count_in_place(138);
	}
	return marking;
}
bool is_enabled(int transition_id, int process_id, const std::vector<int> &marking, int ignored_place) {
	switch (transition_id) {
		case 117:
		{
			if (marking[4 * process_id + 0] == 0 && 119 != ignored_place) return false;
			if (marking[4 * process_id + 1] == 0 && 127 != ignored_place) return false;
			break;
		}

		case 116:
		{
			if (marking[4 * process_id + 0] == 0 && 119 != ignored_place) return false;
			break;
		}

		case 140:
		{
			if (marking[4 * process_id + 3] == 0 && 138 != ignored_place) return false;
			break;
		}

		case 131:
		{
			if (marking[4 * process_id + 2] == 0 && 134 != ignored_place) return false;
			break;
		}

		default:
		fprintf(stderr, "Internal error");
		abort();
	}
	return true;
}
void pack_final_marking(ca::NetBase *net, ca::Packer &packer)
{
	Net_101 *n = (Net_101 *) net;
}
};
int main(int argc, char **argv)
{
	ca::project_description("<project library-octave=\"False\" library-rpc=\"False\" target_env=\"C++\"><configuration><parameter default=\"1\" description=\"\" name=\"JOBS\" policy=\"mandatory\" type=\"int\" /><build-option name=\"LIBS\" /><build-option name=\"CFLAGS\">-O2</build-option><head-code>\nint up(ca::Context &amp;ctx) {\n\treturn (ctx.process_id() + 1) % ctx.process_count();\n}\n\nint down(ca::Context &amp;ctx) {\n\treturn (ctx.process_id() - 1 + ctx.process_count()) % ctx.process_count();\n}</head-code></configuration><net id=\"101\" name=\"loadbalancing\"><area id=\"144\" sx=\"129\" sy=\"86\" x=\"-693\" y=\"-205\"><init x=\"-672\" y=\"-222\">ctx.all_processes()</init></area><area id=\"145\" sx=\"92\" sy=\"68\" x=\"-252\" y=\"-102\"><init x=\"-252\" y=\"-117\">ctx.all_processes()</init></area><place id=\"119\" label-x=\"-216\" label-y=\"-66\" name=\"119\" radius=\"20\" sx=\"18\" sy=\"0\" x=\"-216\" y=\"-66\"><place-type x=\"-186\" y=\"-54\">int</place-type><init x=\"-199\" y=\"-96\" /><code>\tfor (int i = 0; i &lt; param::JOBS(); i++) {\n\t\tplace.add(ctx.process_id() * param::JOBS() + i);\n\t}\n</code><trace trace-tokens=\"False\" /></place><place id=\"127\" label-x=\"-468\" label-y=\"30\" name=\"127\" radius=\"20\" sx=\"30\" sy=\"0\" x=\"-468\" y=\"30\"><place-type x=\"-432\" y=\"48\">int</place-type><init x=\"-451\" y=\"0\" /><trace trace-tokens=\"False\" /></place><place id=\"134\" label-x=\"-630\" label-y=\"-156\" name=\"134\" radius=\"20\" sx=\"6\" sy=\"0\" x=\"-630\" y=\"-156\"><place-type x=\"-624\" y=\"-138\">int</place-type><init x=\"-678\" y=\"-192\">[down(ctx); up(ctx)]</init><trace trace-tokens=\"False\" /></place><place id=\"138\" label-x=\"-36\" label-y=\"30\" name=\"138\" radius=\"20\" sx=\"30\" sy=\"0\" x=\"-36\" y=\"30\"><place-type x=\"12\" y=\"42\">int</place-type><init x=\"-19\" y=\"0\" /><trace trace-tokens=\"False\" /></place><transition clock=\"False\" collective=\"False\" id=\"116\" label-x=\"-19\" label-y=\"-66\" name=\"116\" priority=\"3\" sx=\"70\" sy=\"36\" x=\"-54\" y=\"-84\"><guard x=\"-54\" y=\"-104\" /></transition><transition clock=\"False\" collective=\"False\" id=\"117\" label-x=\"-451\" label-y=\"-66\" name=\"117\" priority=\"4\" sx=\"70\" sy=\"36\" x=\"-486\" y=\"-84\"><guard x=\"-486\" y=\"-104\" /></transition><transition clock=\"False\" collective=\"False\" id=\"131\" label-x=\"-643\" label-y=\"-66\" name=\"131\" priority=\"1\" sx=\"100\" sy=\"36\" x=\"-678\" y=\"-84\"><guard x=\"-678\" y=\"-104\" /></transition><transition clock=\"False\" collective=\"False\" id=\"140\" label-x=\"-361\" label-y=\"30\" name=\"140\" priority=\"2\" sx=\"70\" sy=\"36\" x=\"-396\" y=\"12\"><guard x=\"-396\" y=\"-8\" /><code>\tctx.quit();\n</code></transition><edge from_item=\"119\" id=\"120\" to_item=\"116\"><inscription x=\"-129.0\" y=\"-84.0\">job</inscription></edge><edge from_item=\"119\" id=\"126\" to_item=\"117\"><inscription x=\"-373.0\" y=\"-84.0\">[guard(size &gt; 2)]job</inscription></edge><edge from_item=\"127\" id=\"130\" to_item=\"117\"><inscription x=\"-445.0\" y=\"-18.0\">neighbor</inscription></edge><edge from_item=\"131\" id=\"132\" to_item=\"127\"><inscription x=\"-624.0\" y=\"12.0\">ctx.process_id()@neighbor</inscription><point x=\"-630\" y=\"30\" /></edge><edge from_item=\"117\" id=\"133\" to_item=\"119\"><inscription x=\"-360.0\" y=\"-162.0\">job@neighbor</inscription><point x=\"-408\" y=\"-144\" /><point x=\"-252\" y=\"-144\" /></edge><edge from_item=\"134\" id=\"135\" to_item=\"131\"><inscription x=\"-621.0\" y=\"-113.0\">neighbor</inscription></edge><edge from_item=\"117\" id=\"136\" to_item=\"134\"><inscription x=\"-595.0\" y=\"-150.0\">ctx.process_id()@neighbor</inscription><point x=\"-450\" y=\"-156\" /></edge><edge from_item=\"116\" id=\"139\" to_item=\"138\"><inscription x=\"-13.0\" y=\"-24.0\">job@0</inscription></edge><edge from_item=\"138\" id=\"141\" to_item=\"140\"><inscription x=\"-324.0\" y=\"12.0\">[guard(size == param::JOBS() * ctx.process_count())]</inscription></edge></net></project>");
	std::vector<ca::Parameter*> parameters;
	parameters.push_back(&param::JOBS);

	cass::init(argc, argv, parameters, false);

	ca::NetDef *def_101 = new ca::NetDef(0, 101, spawn_101);
	def_101->register_transition(&transition_117);
	def_101->register_transition(&transition_116);
	def_101->register_transition(&transition_140);
	def_101->register_transition(&transition_131);
	ca::NetDef *defs[] = {def_101};
	ca::setup(1, defs, false);
	VerifConfiguration verif_configuration;
	cass::Core core(argc, argv, verif_configuration, parameters);
	core.generate();
	core.postprocess();
	return 0;
}
#line 1 "*140/function"
void transition_user_fn_140(ca::Context &ctx, Vars_140 &var)
{
	ctx.quit();
}
#line 1 "*119/init_function"
void place_user_fn_119(ca::Context &ctx, ca::TokenList<int > &place)
{
	for (int i = 0; i < param::JOBS(); i++) {
		place.add(ctx.process_id() * param::JOBS() + i);
	}
}
