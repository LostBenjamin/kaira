/* This file is automatically generated
   do not edit this file directly! */

#include "workers.h"
#include <caverif.h>
ca::ParameterInt param::LIMIT("LIMIT", "", ca::PARAMETER_MANDATORY);
ca::ParameterInt param::SIZE("SIZE", "", ca::PARAMETER_MANDATORY);
void place_user_fn_104(ca::Context &ctx, ca::TokenList<Results > &place);
class Vars_107 {
	public:
	Vars_107(ca::Context &ctx,Results &results,int &start) : ctx(ctx),results(results),start(start) {
	}
	ca::Context &ctx;
	Results &results;
	int &start;
};
void transition_user_fn_107(ca::Context &ctx, Vars_107 &var);
class Tokens_107  : public ca::Binding {
	public:
	Tokens_107() {};
	Tokens_107(const Tokens_107 &t) {
		if (t.token_1001 != NULL) {
			token_1001 = new ca::Token<int >(t.token_1001->value);
		} else {
			token_1001 = NULL;
		}
		if (t.token_1003 != NULL) {
			token_1003 = new ca::Token<Results >(t.token_1003->value);
		} else {
			token_1003 = NULL;
		}
	}
	Tokens_107& operator=(const Tokens_107 &t) {
		if (this != &t) {
			if (t.token_1001 != NULL) {
				delete token_1001;
				token_1001 = new ca::Token<int >(t.token_1001->value);
			} else {
				token_1001 = NULL;
			}
			if (t.token_1003 != NULL) {
				delete token_1003;
				token_1003 = new ca::Token<Results >(t.token_1003->value);
			} else {
				token_1003 = NULL;
			}
		}
		return *this;
	}
	~Tokens_107() {
		if (token_1001 != NULL) {
			delete token_1001;
		}
		if (token_1003 != NULL) {
			delete token_1003;
		}
	}
	ca::Binding* copy() {
		Tokens_107 *t = new Tokens_107(*this);
		return t;
	}
	ca::Token<int > *token_1001;
	ca::Token<Results > *token_1003;
};
class Transition_107  : public ca::TransitionDef {
	public:
	Transition_107() : ca::TransitionDef(107, "write and divide", ca::TRANSITION_NORMAL, 0) {
	}
	ca::FireResult full_fire(ca::ThreadBase *thread, ca::NetBase *net);
	ca::Binding* fire_phase1(ca::ThreadBase *thread, ca::NetBase *net);
	void fire_phase2(ca::ThreadBase *thread, ca::NetBase *net, ca::Binding *data);
	bool is_enable(ca::ThreadBase *thread, ca::NetBase *net);
	void pack_binding(ca::Packer &packer, ca::Binding *data);
	ca::Binding* unpack_binding(ca::Unpacker &unpacker);
	ca::FireResult full_fire_with_binding(ca::ThreadBase *thread, ca::NetBase *net, ca::Packer &__kaira__packer);
};
static Transition_107 transition_107;

class Vars_108 {
	public:
	Vars_108(ca::Context &ctx,Job &job,Results &results) : ctx(ctx),job(job),results(results) {
	}
	ca::Context &ctx;
	Job &job;
	Results &results;
};
void transition_user_fn_108(ca::Context &ctx, Vars_108 &var);
class Tokens_108  : public ca::Binding {
	public:
	Tokens_108() {};
	Tokens_108(const Tokens_108 &t) {
		if (t.token_1009 != NULL) {
			token_1009 = new ca::Token<Job >(t.token_1009->value);
		} else {
			token_1009 = NULL;
		}
	}
	Tokens_108& operator=(const Tokens_108 &t) {
		if (this != &t) {
			if (t.token_1009 != NULL) {
				delete token_1009;
				token_1009 = new ca::Token<Job >(t.token_1009->value);
			} else {
				token_1009 = NULL;
			}
		}
		return *this;
	}
	~Tokens_108() {
		if (token_1009 != NULL) {
			delete token_1009;
		}
	}
	ca::Binding* copy() {
		Tokens_108 *t = new Tokens_108(*this);
		return t;
	}
	ca::Token<Job > *token_1009;
};
class Transition_108  : public ca::TransitionDef {
	public:
	Transition_108() : ca::TransitionDef(108, "compute", ca::TRANSITION_NORMAL, 0) {
	}
	ca::FireResult full_fire(ca::ThreadBase *thread, ca::NetBase *net);
	ca::Binding* fire_phase1(ca::ThreadBase *thread, ca::NetBase *net);
	void fire_phase2(ca::ThreadBase *thread, ca::NetBase *net, ca::Binding *data);
	bool is_enable(ca::ThreadBase *thread, ca::NetBase *net);
	void pack_binding(ca::Packer &packer, ca::Binding *data);
	ca::Binding* unpack_binding(ca::Unpacker &unpacker);
	ca::FireResult full_fire_with_binding(ca::ThreadBase *thread, ca::NetBase *net, ca::Packer &__kaira__packer);
};
static Transition_108 transition_108;

class Vars_109 {
	public:
	Vars_109(ca::Context &ctx,ca::TokenList<Results > &results) : ctx(ctx),results(results) {
	}
	ca::Context &ctx;
	ca::TokenList<Results > &results;
};
void transition_user_fn_109(ca::Context &ctx, Vars_109 &var);
class Tokens_109  : public ca::Binding {
	public:
	Tokens_109() {};
	Tokens_109(const Tokens_109 &t) {
		if (t.token_1013 != NULL) {
			token_1013 = new ca::Token<int >(t.token_1013->value);
		} else {
			token_1013 = NULL;
		}
		tokens_1016 = t.tokens_1016;
	}
	Tokens_109& operator=(const Tokens_109 &t) {
		if (this != &t) {
			if (t.token_1013 != NULL) {
				delete token_1013;
				token_1013 = new ca::Token<int >(t.token_1013->value);
			} else {
				token_1013 = NULL;
			}
			tokens_1016 = t.tokens_1016;
		}
		return *this;
	}
	~Tokens_109() {
		if (token_1013 != NULL) {
			delete token_1013;
		}
	}
	ca::Binding* copy() {
		Tokens_109 *t = new Tokens_109(*this);
		return t;
	}
	ca::Token<int > *token_1013;
	ca::Place<Results > tokens_1016;
};
class Transition_109  : public ca::TransitionDef {
	public:
	Transition_109() : ca::TransitionDef(109, "write final results", ca::TRANSITION_NORMAL, 0) {
	}
	ca::FireResult full_fire(ca::ThreadBase *thread, ca::NetBase *net);
	ca::Binding* fire_phase1(ca::ThreadBase *thread, ca::NetBase *net);
	void fire_phase2(ca::ThreadBase *thread, ca::NetBase *net, ca::Binding *data);
	bool is_enable(ca::ThreadBase *thread, ca::NetBase *net);
	void pack_binding(ca::Packer &packer, ca::Binding *data);
	ca::Binding* unpack_binding(ca::Unpacker &unpacker);
	ca::FireResult full_fire_with_binding(ca::ThreadBase *thread, ca::NetBase *net, ca::Packer &__kaira__packer);
};
static Transition_109 transition_109;

class Net_0  : public cass::Net {
	public:
	ca::NetBase * copy() {
		Net_0 *net = new Net_0(*this);
		return net;
	}
	ca::Place<int > place_103;
	ca::Place<Results > place_104;
	ca::Place<Job > place_105;
	void write_reports_content(ca::ThreadBase *thread, ca::Output &output) {
		output.child("place");
		output.set("id", 103);
		{
			ca::Token<int > *t = place_103.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_103.begin());
			}
		}
		output.back();
		output.child("place");
		output.set("id", 104);
		{
			ca::Token<Results > *t = place_104.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_104.begin());
			}
		}
		output.back();
		output.child("place");
		output.set("id", 105);
		{
			ca::Token<Job > *t = place_105.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_105.begin());
			}
		}
		output.back();
	}
	void receive(ca::ThreadBase *__kaira__thread, int from_process, int place_pos, ca::Unpacker &unpacker) {
		switch(place_pos) {
		case 119:
		{
			ca::Token<Job > *token = new ca::Token<Job >();
			ca::unpack(unpacker, token->value);
			this->place_105.add_token(token);
			this->activate_transition_by_pos_id(1);
		}
		break;
		case 117:
		{
			ca::Token<Results > *token = new ca::Token<Results >();
			ca::unpack(unpacker, token->value);
			this->place_104.add_token(token);
			this->activate_transition_by_pos_id(0);
			this->activate_transition_by_pos_id(2);
		}
		break;
		}
	}
	cass::Net * copy_without_tokens() {
		Net_0 *net = new Net_0();
		return net;
	}
	void pack(ca::Packer &packer) {
		ca::pack(packer, place_103);
		ca::pack(packer, place_104);
		ca::pack(packer, place_105);
	}
	void unpack(ca::Unpacker &unpacker) {
		ca::unpack(unpacker, place_103);
		ca::unpack(unpacker, place_104);
		ca::unpack(unpacker, place_105);
	}
	size_t get_token_count_in_place(int place_id) {
		if (place_id == 103) return this->place_103.size();
		if (place_id == 104) return this->place_104.size();
		if (place_id == 105) return this->place_105.size();
		return 0;
	}
};
ca::NetBase * spawn_0(ca::ThreadBase *__kaira__thread, ca::NetDef *__kaira__def) {
	Net_0 *__kaira__net = new Net_0();
	ca::Context ctx(__kaira__thread, __kaira__net);
	int __kaira__pid = __kaira__thread->get_process_id();
	if (__kaira__pid == 0) {
		__kaira__net->place_103.add(0);
	}
	if (__kaira__pid == 0) {
		{
			ca::TokenList<Results > __kaira__list;
			place_user_fn_104(ctx, __kaira__list);
			__kaira__net->place_104.overtake(__kaira__list);
		}
	}
	return __kaira__net;
}
ca::FireResult Transition_107::full_fire(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return ca::NOT_ENABLED;
	if (__kaira__n->place_104.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=112 uid=1001 expr=start
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_103.begin();
	int &start = __kaira__token_1001->value;
	// Inscription id=112 uid=1003 expr=results
	ca::Token < Results > *__kaira__token_1003;
	__kaira__token_1003 = __kaira__n->place_104.begin();
	Results &results = __kaira__token_1003->value;
	if (!(start < param::LIMIT())) {
		return ca::NOT_ENABLED;
	}
	{
		{
			__kaira__n->place_103.remove(__kaira__token_1001);
			__kaira__n->place_104.remove(__kaira__token_1003);
		}
		__kaira__n->activate_transition_by_pos_id(0);
		Vars_107 __kaira__vars(ctx,results,start);
		transition_user_fn_107(ctx, __kaira__vars);
		__kaira__n->place_103.add(start + param::SIZE());
		__kaira__n->activate_transition_by_pos_id(0);
		__kaira__n->activate_transition_by_pos_id(2);
		if (results.process == __kaira__thread->get_process_id()) {
			__kaira__n->place_105.add(Job(start, start + param::SIZE()));
			__kaira__n->activate_transition_by_pos_id(1);
		} else {
			int __kaira__target = results.process;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (Job(start, start + param::SIZE())));
				__kaira__thread->send(__kaira__target, __kaira__n, 119, 1, __kaira__packer);
			}
			delete __kaira__token_1001;
			delete __kaira__token_1003;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::Binding* Transition_107::fire_phase1(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return NULL;
	if (__kaira__n->place_104.size() < 1) return NULL;
	// Inscription id=112 uid=1001 expr=start
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_103.begin();
	int &start = __kaira__token_1001->value;
	// Inscription id=112 uid=1003 expr=results
	ca::Token < Results > *__kaira__token_1003;
	__kaira__token_1003 = __kaira__n->place_104.begin();
	Results &results = __kaira__token_1003->value;
	if (!(start < param::LIMIT())) {
		return NULL;
	}
	{
		{
			__kaira__n->place_103.remove(__kaira__token_1001);
			__kaira__n->place_104.remove(__kaira__token_1003);
		}
		Tokens_107 *__kaira__tokens = new Tokens_107();
		__kaira__tokens->token_1001 = __kaira__token_1001;
		__kaira__tokens->token_1003 = __kaira__token_1003;
		return __kaira__tokens;
	}
	return NULL;
}
void Transition_107::fire_phase2(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Binding *__kaira__binding)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	Tokens_107 *__kaira__tokens = static_cast<Tokens_107*>(__kaira__binding);
	ca::Token<int > *__kaira__token_1001 = __kaira__tokens->token_1001;
	ca::Token<Results > *__kaira__token_1003 = __kaira__tokens->token_1003;
	int &start = __kaira__token_1001->value;
	Results &results = __kaira__token_1003->value;
	__kaira__n->activate_transition_by_pos_id(0);
	Vars_107 __kaira__vars(ctx,results,start);
	transition_user_fn_107(ctx, __kaira__vars);
	__kaira__n->place_103.add(start + param::SIZE());
	__kaira__n->activate_transition_by_pos_id(0);
	__kaira__n->activate_transition_by_pos_id(2);
	if (results.process == __kaira__thread->get_process_id()) {
		__kaira__n->place_105.add(Job(start, start + param::SIZE()));
		__kaira__n->activate_transition_by_pos_id(1);
} else {
	int __kaira__target = results.process;
		ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
		ca::pack(__kaira__packer, (Job(start, start + param::SIZE())));
		__kaira__thread->send(__kaira__target, __kaira__n, 119, 1, __kaira__packer);
	}
	delete __kaira__binding;
}
bool Transition_107::is_enable(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return false;
	if (__kaira__n->place_104.size() < 1) return false;
	// Inscription id=112 uid=1001 expr=start
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_103.begin();
	int &start = __kaira__token_1001->value;
	// Inscription id=112 uid=1003 expr=results
	ca::Token < Results > *__kaira__token_1003;
	__kaira__token_1003 = __kaira__n->place_104.begin();
	Results &results = __kaira__token_1003->value;
	if (!(start < param::LIMIT())) {
		return false;
	}
	{
		return true;
	}
	return false;
}
void Transition_107::pack_binding(ca::Packer &packer, ca::Binding *binding)
{
	Tokens_107 *tokens = static_cast<Tokens_107*>(binding);
	ca::pack(packer, tokens->token_1001->value);
	ca::pack(packer, tokens->token_1003->value);
}
ca::Binding* Transition_107::unpack_binding(ca::Unpacker &unpacker)
{
	Tokens_107 *tokens = new Tokens_107;
	tokens->token_1001 = new ca::Token<int >;
	ca::unpack(unpacker, tokens->token_1001->value);
	tokens->token_1003 = new ca::Token<Results >;
	ca::unpack(unpacker, tokens->token_1003->value);
	return tokens;
}
ca::FireResult Transition_107::full_fire_with_binding(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Packer &__kaira__packer)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return ca::NOT_ENABLED;
	if (__kaira__n->place_104.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=112 uid=1001 expr=start
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_103.begin();
	int &start = __kaira__token_1001->value;
	// Inscription id=112 uid=1003 expr=results
	ca::Token < Results > *__kaira__token_1003;
	__kaira__token_1003 = __kaira__n->place_104.begin();
	Results &results = __kaira__token_1003->value;
	if (!(start < param::LIMIT())) {
		return ca::NOT_ENABLED;
	}
	{
		ca::pack(__kaira__packer, __kaira__token_1001->value);
		ca::pack(__kaira__packer, __kaira__token_1003->value);
		{
			__kaira__n->place_103.remove(__kaira__token_1001);
			__kaira__n->place_104.remove(__kaira__token_1003);
		}
		__kaira__n->activate_transition_by_pos_id(0);
		Vars_107 __kaira__vars(ctx,results,start);
		transition_user_fn_107(ctx, __kaira__vars);
		__kaira__n->place_103.add(start + param::SIZE());
		__kaira__n->activate_transition_by_pos_id(0);
		__kaira__n->activate_transition_by_pos_id(2);
		if (results.process == __kaira__thread->get_process_id()) {
			__kaira__n->place_105.add(Job(start, start + param::SIZE()));
			__kaira__n->activate_transition_by_pos_id(1);
		} else {
			int __kaira__target = results.process;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (Job(start, start + param::SIZE())));
				__kaira__thread->send(__kaira__target, __kaira__n, 119, 1, __kaira__packer);
			}
			delete __kaira__token_1001;
			delete __kaira__token_1003;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::FireResult Transition_108::full_fire(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_105.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=113 uid=1009 expr=job
	ca::Token < Job > *__kaira__token_1009;
	__kaira__token_1009 = __kaira__n->place_105.begin();
	Job &job = __kaira__token_1009->value;
	{
		{
			__kaira__n->place_105.remove(__kaira__token_1009);
		}
		__kaira__n->activate_transition_by_pos_id(1);
		Results results; // Fresh variable
		Vars_108 __kaira__vars(ctx,job,results);
		transition_user_fn_108(ctx, __kaira__vars);
		if (0 == __kaira__thread->get_process_id()) {
			__kaira__n->place_104.add(results);
			__kaira__n->activate_transition_by_pos_id(0);
			__kaira__n->activate_transition_by_pos_id(2);
		} else {
			int __kaira__target = 0;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (results));
				__kaira__thread->send(__kaira__target, __kaira__n, 117, 1, __kaira__packer);
			}
			delete __kaira__token_1009;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::Binding* Transition_108::fire_phase1(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_105.size() < 1) return NULL;
	// Inscription id=113 uid=1009 expr=job
	ca::Token < Job > *__kaira__token_1009;
	__kaira__token_1009 = __kaira__n->place_105.begin();
	Job &job = __kaira__token_1009->value;
	{
		{
			__kaira__n->place_105.remove(__kaira__token_1009);
		}
		Tokens_108 *__kaira__tokens = new Tokens_108();
		__kaira__tokens->token_1009 = __kaira__token_1009;
		return __kaira__tokens;
	}
	return NULL;
}
void Transition_108::fire_phase2(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Binding *__kaira__binding)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	Tokens_108 *__kaira__tokens = static_cast<Tokens_108*>(__kaira__binding);
	ca::Token<Job > *__kaira__token_1009 = __kaira__tokens->token_1009;
	Job &job = __kaira__token_1009->value;
	__kaira__n->activate_transition_by_pos_id(1);
	Results results; // Fresh variable
	Vars_108 __kaira__vars(ctx,job,results);
	transition_user_fn_108(ctx, __kaira__vars);
	if (0 == __kaira__thread->get_process_id()) {
		__kaira__n->place_104.add(results);
		__kaira__n->activate_transition_by_pos_id(0);
		__kaira__n->activate_transition_by_pos_id(2);
} else {
	int __kaira__target = 0;
		ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
		ca::pack(__kaira__packer, (results));
		__kaira__thread->send(__kaira__target, __kaira__n, 117, 1, __kaira__packer);
	}
	delete __kaira__binding;
}
bool Transition_108::is_enable(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_105.size() < 1) return false;
	// Inscription id=113 uid=1009 expr=job
	ca::Token < Job > *__kaira__token_1009;
	__kaira__token_1009 = __kaira__n->place_105.begin();
	Job &job = __kaira__token_1009->value;
	{
		return true;
	}
	return false;
}
void Transition_108::pack_binding(ca::Packer &packer, ca::Binding *binding)
{
	Tokens_108 *tokens = static_cast<Tokens_108*>(binding);
	ca::pack(packer, tokens->token_1009->value);
}
ca::Binding* Transition_108::unpack_binding(ca::Unpacker &unpacker)
{
	Tokens_108 *tokens = new Tokens_108;
	tokens->token_1009 = new ca::Token<Job >;
	ca::unpack(unpacker, tokens->token_1009->value);
	return tokens;
}
ca::FireResult Transition_108::full_fire_with_binding(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Packer &__kaira__packer)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_105.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=113 uid=1009 expr=job
	ca::Token < Job > *__kaira__token_1009;
	__kaira__token_1009 = __kaira__n->place_105.begin();
	Job &job = __kaira__token_1009->value;
	{
		ca::pack(__kaira__packer, __kaira__token_1009->value);
		{
			__kaira__n->place_105.remove(__kaira__token_1009);
		}
		__kaira__n->activate_transition_by_pos_id(1);
		Results results; // Fresh variable
		Vars_108 __kaira__vars(ctx,job,results);
		transition_user_fn_108(ctx, __kaira__vars);
		if (0 == __kaira__thread->get_process_id()) {
			__kaira__n->place_104.add(results);
			__kaira__n->activate_transition_by_pos_id(0);
			__kaira__n->activate_transition_by_pos_id(2);
		} else {
			int __kaira__target = 0;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (results));
				__kaira__thread->send(__kaira__target, __kaira__n, 117, 1, __kaira__packer);
			}
			delete __kaira__token_1009;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::FireResult Transition_109::full_fire(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=115 uid=1013 expr=param::LIMIT()
	ca::Token < int > *__kaira__token_1013;
	__kaira__token_1013 = __kaira__n->place_103.begin();
	if (!((__kaira__token_1013->value) == (param::LIMIT()))) {
		return ca::NOT_ENABLED;
	}
	if (__kaira__token_1013->value != (param::LIMIT())) {
		return ca::NOT_ENABLED;
	}
	{
		size_t size = __kaira__n->place_104.size();
		if (!(size == ctx.process_count() - 1)) {
			return ca::NOT_ENABLED;
		}
	}
	{
		{
			__kaira__n->place_103.remove(__kaira__token_1013);
		}
		__kaira__n->activate_transition_by_pos_id(2);
		ca::TokenList<Results > results;
		__kaira__n->place_104.put_into(results);
		Vars_109 __kaira__vars(ctx,results);
		transition_user_fn_109(ctx, __kaira__vars);
		delete __kaira__token_1013;
		return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::Binding* Transition_109::fire_phase1(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return NULL;
	// Inscription id=115 uid=1013 expr=param::LIMIT()
	ca::Token < int > *__kaira__token_1013;
	__kaira__token_1013 = __kaira__n->place_103.begin();
	if (!((__kaira__token_1013->value) == (param::LIMIT()))) {
		return NULL;
	}
	if (__kaira__token_1013->value != (param::LIMIT())) {
		return NULL;
	}
	{
		size_t size = __kaira__n->place_104.size();
		if (!(size == ctx.process_count() - 1)) {
			return NULL;
		}
	}
	{
		{
			__kaira__n->place_103.remove(__kaira__token_1013);
		}
		Tokens_109 *__kaira__tokens = new Tokens_109();
		__kaira__tokens->token_1013 = __kaira__token_1013;
		__kaira__tokens->tokens_1016.overtake(__kaira__n->place_104);
		return __kaira__tokens;
	}
	return NULL;
}
void Transition_109::fire_phase2(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Binding *__kaira__binding)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	Tokens_109 *__kaira__tokens = static_cast<Tokens_109*>(__kaira__binding);
	ca::Token<int > *__kaira__token_1013 = __kaira__tokens->token_1013;
	__kaira__n->activate_transition_by_pos_id(2);
	ca::TokenList<Results > results;
	__kaira__tokens->tokens_1016.put_into(results);
	Vars_109 __kaira__vars(ctx,results);
	transition_user_fn_109(ctx, __kaira__vars);
	delete __kaira__binding;
}
bool Transition_109::is_enable(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return false;
	// Inscription id=115 uid=1013 expr=param::LIMIT()
	ca::Token < int > *__kaira__token_1013;
	__kaira__token_1013 = __kaira__n->place_103.begin();
	if (!((__kaira__token_1013->value) == (param::LIMIT()))) {
		return false;
	}
	if (__kaira__token_1013->value != (param::LIMIT())) {
		return false;
	}
	{
		size_t size = __kaira__n->place_104.size();
		if (!(size == ctx.process_count() - 1)) {
			return false;
		}
	}
	{
		return true;
	}
	return false;
}
void Transition_109::pack_binding(ca::Packer &packer, ca::Binding *binding)
{
	Tokens_109 *tokens = static_cast<Tokens_109*>(binding);
	ca::pack(packer, tokens->token_1013->value);
	ca::pack(packer, tokens->tokens_1016);
}
ca::Binding* Transition_109::unpack_binding(ca::Unpacker &unpacker)
{
	Tokens_109 *tokens = new Tokens_109;
	tokens->token_1013 = new ca::Token<int >;
	ca::unpack(unpacker, tokens->token_1013->value);
	ca::unpack(unpacker, tokens->tokens_1016);
	return tokens;
}
ca::FireResult Transition_109::full_fire_with_binding(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Packer &__kaira__packer)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=115 uid=1013 expr=param::LIMIT()
	ca::Token < int > *__kaira__token_1013;
	__kaira__token_1013 = __kaira__n->place_103.begin();
	if (!((__kaira__token_1013->value) == (param::LIMIT()))) {
		return ca::NOT_ENABLED;
	}
	if (__kaira__token_1013->value != (param::LIMIT())) {
		return ca::NOT_ENABLED;
	}
	{
		size_t size = __kaira__n->place_104.size();
		if (!(size == ctx.process_count() - 1)) {
			return ca::NOT_ENABLED;
		}
	}
	{
		ca::pack(__kaira__packer, __kaira__token_1013->value);
		ca::pack(__kaira__packer, __kaira__n->place_104);
		{
			__kaira__n->place_103.remove(__kaira__token_1013);
		}
		__kaira__n->activate_transition_by_pos_id(2);
		ca::TokenList<Results > results;
		__kaira__n->place_104.put_into(results);
		Vars_109 __kaira__vars(ctx,results);
		transition_user_fn_109(ctx, __kaira__vars);
		delete __kaira__token_1013;
		return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
class VerifConfiguration : public cass::VerifConfiguration {
public:
VerifConfiguration()
{
}
bool is_dependent(const cass::Action &a1, const cass::Action &a2, const std::vector<int> &marking)
{
	cass::VerifThread thread(a1.process);
	ca::Context ctx(&thread, NULL);
	if (a1.type == cass::ActionFire && a2.type == cass::ActionFire) {
	}
	if (a1.process != a2.process) {
		return false;
	}
	if (a1.type == cass::ActionFire && a2.type == cass::ActionFire) {
		if (a1.data.fire.transition_def->get_id() == a2.data.fire.transition_def->get_id()) {
			fprintf(stderr, "Internal error - The same transitions in POR.\n");
			abort();
		}
		switch (a1.data.fire.transition_def->get_id()) {
			case 107:
			{
				switch (a2.data.fire.transition_def->get_id()) {
					case 108:
					{
						return true; // Both transitions send tokens but we don't know exactly where
						break;
					}

					case 109:
					{
						return true; // Transitions taking tokens from the same input place
						break;
					}

					default:
					fprintf(stderr, "Internal error");
					abort();
				}
				break;
			}

			case 108:
			{
				switch (a2.data.fire.transition_def->get_id()) {
					case 107:
					{
						return true; // Both transitions send tokens but we don't know exactly where
						break;
					}

					case 109:
					{
						// A transition putting tokens to a input place of a bulk transition
						if (a1.process == (0)) return true;
						return false;
						break;
					}

					default:
					fprintf(stderr, "Internal error");
					abort();
				}
				break;
			}

			case 109:
			{
				switch (a2.data.fire.transition_def->get_id()) {
					case 107:
					{
						return true; // Transitions taking tokens from the same input place
						break;
					}

					case 108:
					{
						// A transition putting tokens to a input place of a bulk transition
						if (a1.process == (0)) return true;
						return false;
						break;
					}

					default:
					fprintf(stderr, "Internal error");
					abort();
				}
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
	}
	if (a1.type == cass::ActionFire && a2.type == cass::ActionReceive) {
		switch (a2.data.receive.edge_id) {
			case 111:
			{
				// t 107 --> p 103
				int edge_priority = 0;
				if (is_enabled(107, a1.process, marking, 103)) edge_priority = 0;
				if (is_enabled(109, a1.process, marking, 103)) edge_priority = 0;
				if (edge_priority > 0 && 107 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 108 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 109 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 119:
			{
				// t 107 --> p 105
				int edge_priority = 0;
				if (is_enabled(108, a1.process, marking, 105)) edge_priority = 0;
				if (edge_priority > 0 && 107 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 108 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 109 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 117:
			{
				// t 108 --> p 104
				int edge_priority = 0;
				if (is_enabled(107, a1.process, marking, 104)) edge_priority = 0;
				if (is_enabled(109, a1.process, marking, 104)) edge_priority = 0;
				if (edge_priority > 0 && 107 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 108 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 109 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
		switch (a1.data.fire.transition_def->get_id()) {
			case 107:
			{
				// t 107 --> p 103
				if (a2.data.receive.edge_id == 111) {
					return true;
				}
				// t 107 --> p 105
				if (a2.data.receive.edge_id == 119) {
					return true;
				}
				return false;
				break;
			}

			case 108:
			{
				// t 108 --> p 104
				if (a2.data.receive.edge_id == 117) {
					if (a1.process != (0)) {
						return false;
					}
					return true;
				}
				return false;
				break;
			}

			case 109:
			{
				// t 108 --> p 104
				if (a2.data.receive.edge_id == 117) return true;
				return false;
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
	}
	if (a1.type == cass::ActionReceive && a2.type == cass::ActionFire) {
		switch (a1.data.receive.edge_id) {
			case 111:
			{
				// t 107 --> p 103
				int edge_priority = 0;
				if (is_enabled(107, a1.process, marking, 103)) edge_priority = 0;
				if (is_enabled(109, a1.process, marking, 103)) edge_priority = 0;
				if (edge_priority > 0 && 107 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 108 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 109 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 119:
			{
				// t 107 --> p 105
				int edge_priority = 0;
				if (is_enabled(108, a1.process, marking, 105)) edge_priority = 0;
				if (edge_priority > 0 && 107 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 108 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 109 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 117:
			{
				// t 108 --> p 104
				int edge_priority = 0;
				if (is_enabled(107, a1.process, marking, 104)) edge_priority = 0;
				if (is_enabled(109, a1.process, marking, 104)) edge_priority = 0;
				if (edge_priority > 0 && 107 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 108 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 109 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
		switch (a2.data.fire.transition_def->get_id()) {
			case 107:
			{
				// t 107 --> p 103
				if (a1.data.receive.edge_id == 111) {
					return true;
				}
				// t 107 --> p 105
				if (a1.data.receive.edge_id == 119) {
					return true;
				}
				return false;
				break;
			}

			case 108:
			{
				// t 108 --> p 104
				if (a1.data.receive.edge_id == 117) {
					if (a1.process != (0)) {
						return false;
					}
					return true;
				}
				return false;
				break;
			}

			case 109:
			{
				// t 108 --> p 104
				if (a1.data.receive.edge_id == 117) return true;
				return false;
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
	}
	if (a1.type == cass::ActionReceive && a2.type == cass::ActionReceive) {
		if (a1.data.receive.edge_id == a2.data.receive.edge_id &&a1.data.receive.source == a2.data.receive.source) {
			fprintf(stderr, "Internal error - The same receive actions in POR");
			abort();
		}
		switch (a1.data.receive.edge_id) {
			case 119: // t 107 --> p 105
			return false;
			case 117: // t 108 --> p 104
			return false;
			default: return false;
		}
	}
}
bool is_visible(const cass::Action &action)
{
	if (action.type == cass::ActionFire) {
	}
	return false;
}
bool compare(const cass::Arc &arc1, const cass::Arc &arc2)
{
	if (arc1.nni->data.fire.transition_id == arc2.nni->data.fire.transition_id) {
		switch (arc1.nni->data.fire.transition_id) {
			case 107:
			{
				return arc1.nni->data.fire.process_id < arc2.nni->data.fire.process_id;
			}
			case 108:
			{
				return memcmp(arc1.nni->data.fire.binding, arc2.nni->data.fire.binding, mhash_get_block_size(MHASH_MD5)) < 0;
			}
			case 109:
			{
				return arc1.nni->data.fire.process_id < arc2.nni->data.fire.process_id;
			}
		}
	} else {
		return arc1.nni->data.fire.transition_id < arc2.nni->data.fire.transition_id;
	}
}
void compute_successors(const cass::Action &a,std::deque<cass::Action> &queue,cass::ActionSet &processed,const std::vector<bool> &receive_blocked,const std::vector<int> &enabled_priorities,std::vector<int> &marking,const cass::ActionSet &ample)
{
	cass::Action action;
	cass::VerifThread thread(a.process);
	ca::Context ctx(&thread, NULL);
	switch (a.type) {
		case cass::ActionFire:
		switch (a.data.fire.transition_def->get_id()) {
			case 107:
			{
				const cass::Action &__kaira__a = a;
				// place 103
				// there is 3 places, place 103 is on position 0.
				marking[3 * __kaira__a.process + 0]++;
				if (is_enabled(109, __kaira__a.process, marking, -1)) {
					action.type = cass::ActionFire;
					action.process = __kaira__a.process;
					action.data.fire.transition_def = &transition_109;
					if (enabled_priorities[action.process] <= transition_109.get_priority() && processed.find(action) == processed.end()) {
						queue.push_back(action);
						processed.insert(action);
					}
				}
				// place 105
				// there is 3 places, place 105 is on position 2.
				marking[3 * __kaira__a.process + 2]++;
				if (is_enabled(108, __kaira__a.process, marking, -1)) {
					action.type = cass::ActionFire;
					action.process = __kaira__a.process;
					action.data.fire.transition_def = &transition_108;
					if (enabled_priorities[action.process] <= transition_108.get_priority() && processed.find(action) == processed.end()) {
						queue.push_back(action);
						processed.insert(action);
					}
				}
				for (int __kaira__p = 0; __kaira__p < ca::process_count; __kaira__p++)
				{
					if (__kaira__p != __kaira__a.process) {
						action.type = cass::ActionReceive;
						action.process = __kaira__p;
						action.data.receive.source = a.process;
						action.data.receive.edge_id = 119;
						if (!receive_blocked[action.process * ca::process_count + __kaira__a.process] && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
				}
				return;
				break;
			}

			case 108:
			{
				const cass::Action &__kaira__a = a;
				// place 104
				{
					int __kaira__target = 0;
					if (__kaira__a.process == __kaira__target) {
						// there is 3 places, place 104 is on position 1.
						marking[3 * __kaira__a.process + 1]++;
						if (is_enabled(107, __kaira__a.process, marking, -1)) {
							action.type = cass::ActionFire;
							action.process = __kaira__a.process;
							action.data.fire.transition_def = &transition_107;
							if (enabled_priorities[action.process] <= transition_107.get_priority() && processed.find(action) == processed.end()) {
								queue.push_back(action);
								processed.insert(action);
							}
						}
						if (is_enabled(109, __kaira__a.process, marking, -1)) {
							action.type = cass::ActionFire;
							action.process = __kaira__a.process;
							action.data.fire.transition_def = &transition_109;
							if (enabled_priorities[action.process] <= transition_109.get_priority() && processed.find(action) == processed.end()) {
								queue.push_back(action);
								processed.insert(action);
							}
						}
					} else {
						action.type = cass::ActionReceive;
						action.process = __kaira__target;
						action.data.receive.source = a.process;
						action.data.receive.edge_id = 117;
						if (!receive_blocked[action.process * ca::process_count + __kaira__a.process] && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
				}
				return;
				break;
			}

			case 109:
			{
				const cass::Action &__kaira__a = a;
				return;
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
		case cass::ActionReceive:
		{
			switch (a.data.receive.edge_id) {
				case 119: // t 107 --> p 105
				{
					const cass::Action &__kaira__a = a;
					// there is 3 places, place 105 is on position 2.
					marking[3 * __kaira__a.process + 2]++;
					if (is_enabled(108, __kaira__a.process, marking, -1)) {
						action.type = cass::ActionFire;
						action.process = __kaira__a.process;
						action.data.fire.transition_def = &transition_108;
						if (enabled_priorities[action.process] <= transition_108.get_priority() && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
					return;
				}
				case 117: // t 108 --> p 104
				{
					const cass::Action &__kaira__a = a;
					// there is 3 places, place 104 is on position 1.
					marking[3 * __kaira__a.process + 1]++;
					if (is_enabled(107, __kaira__a.process, marking, -1)) {
						action.type = cass::ActionFire;
						action.process = __kaira__a.process;
						action.data.fire.transition_def = &transition_107;
						if (enabled_priorities[action.process] <= transition_107.get_priority() && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
					if (is_enabled(109, __kaira__a.process, marking, -1)) {
						action.type = cass::ActionFire;
						action.process = __kaira__a.process;
						action.data.fire.transition_def = &transition_109;
						if (enabled_priorities[action.process] <= transition_109.get_priority() && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
					return;
				}
			}
			return;
		}
	}
}
std::vector<int> get_marking(cass::State *s) {
	std::vector<int> marking;
	marking.resize(3 * ca::process_count);
	for (int p = 0; p < ca::process_count; p++) {
		Net_0 *n = (Net_0 *) s->get_net(p);
		marking[p * 3 + 0] = n->get_token_count_in_place(103);
		marking[p * 3 + 1] = n->get_token_count_in_place(104);
		marking[p * 3 + 2] = n->get_token_count_in_place(105);
	}
	return marking;
}
bool is_enabled(int transition_id, int process_id, const std::vector<int> &marking, int ignored_place) {
	switch (transition_id) {
		case 107:
		{
			if (marking[3 * process_id + 0] == 0 && 103 != ignored_place) return false;
			if (marking[3 * process_id + 1] == 0 && 104 != ignored_place) return false;
			break;
		}

		case 108:
		{
			if (marking[3 * process_id + 2] == 0 && 105 != ignored_place) return false;
			break;
		}

		case 109:
		{
			if (marking[3 * process_id + 0] == 0 && 103 != ignored_place) return false;
			break;
		}

		default:
		fprintf(stderr, "Internal error");
		abort();
	}
	return true;
}
void pack_final_marking(ca::NetBase *net, ca::Packer &packer)
{
	Net_0 *n = (Net_0 *) net;
}
};
int main(int argc, char **argv)
{
	ca::project_description("<project library-octave=\"False\" library-rpc=\"False\" target_env=\"C++\"><configuration><parameter default=\"120\" description=\"\" name=\"LIMIT\" policy=\"mandatory\" type=\"int\" /><parameter default=\"10\" description=\"\" name=\"SIZE\" policy=\"mandatory\" type=\"int\" /><build-option name=\"LIBS\" /><build-option name=\"CFLAGS\">-g -O0</build-option><head-code>\nstruct Job {\n\tJob() {};\n\tJob(int start, int end) : start(start), end(end) {}\n\tint start;\n\tint end;\n\n\tvoid pack(ca::Packer &amp;p) const {\n\t\tp &lt;&lt; start &lt;&lt; end;\n\t}\n\n\tvoid unpack(ca::Unpacker &amp;p) {\n\t\tp &gt;&gt; start &gt;&gt; end;\n\t}\n\t\n\tstd::string token_name() const {\n\t\tstd::stringstream s;\n\t\ts &lt;&lt; \"Job [\" &lt;&lt; start &lt;&lt; \",\" &lt;&lt; end &lt;&lt; \")\";\n\t\treturn s.str();\n\t}\n};\n\nstruct Results {\n\tstd::vector&lt;int&gt; primes;\n\tint process;\n\t\n\tResults(): process(-1) { };\n\n\tResults(int process): process(process) {};\n\n\tvoid pack(ca::Packer &amp;p) const {\n\t\tp &lt;&lt; process;\n\t\tp &lt;&lt; primes.size();\n\t\tfor (size_t i = 0; i &lt; primes.size(); i++) {\n\t\t\tp &lt;&lt; primes[i];\n\t\t}\n\t}\n\n\tvoid unpack(ca::Unpacker &amp;p) {\n\t\tsize_t size;\n\t\tp &gt;&gt; process;\n\t\tp &gt;&gt; size;\n\t\tprimes.resize(size);\n\t\tfor (int i = 0; i &lt; size; i++) {\n\t\t\tp &gt;&gt; primes[i];\n\t\t}\n\t}\n\t\n\tstd::string token_name() const {\n\t\treturn \"Results\";\n\t}\t\n\t\n};</head-code></configuration><net id=\"0\" name=\"Main\"><place id=\"103\" label-x=\"38\" label-y=\"255\" name=\"counter\" radius=\"20\" sx=\"4\" sy=\"0\" x=\"38\" y=\"255\"><place-type x=\"65\" y=\"271\">int</place-type><init x=\"52\" y=\"222\">[0]</init><trace trace-tokens=\"False\" /></place><place id=\"104\" label-x=\"186\" label-y=\"252\" name=\"ready\" radius=\"20\" sx=\"0\" sy=\"0\" x=\"186\" y=\"252\"><place-type x=\"203\" y=\"269\">Results</place-type><init x=\"203\" y=\"227\" /><code>\tfor (int i = 1; i &lt; ctx.process_count(); i++) {\n\t\tplace.add(Results(i));\n\t}\n</code><trace trace-tokens=\"False\" /></place><place id=\"105\" label-x=\"415\" label-y=\"165\" name=\"\" radius=\"22\" sx=\"0\" sy=\"0\" x=\"415\" y=\"165\"><place-type x=\"432\" y=\"182\">Job</place-type><init x=\"432\" y=\"135\" /><trace trace-tokens=\"False\" /></place><transition clock=\"False\" collective=\"False\" id=\"107\" label-x=\"258\" label-y=\"116\" name=\"write and divide\" priority=\"\" sx=\"120\" sy=\"35\" x=\"192\" y=\"90\"><guard x=\"192\" y=\"70\">start &lt; param::LIMIT()</guard><code>\n</code><trace>fire</trace><verif-occurrence binding=\"False\" process=\"True\" /></transition><transition clock=\"False\" collective=\"False\" id=\"108\" label-x=\"431\" label-y=\"262\" name=\"compute\" priority=\"\" sx=\"70\" sy=\"35\" x=\"380\" y=\"235\"><guard x=\"380\" y=\"215\" /><code>\tint t;\n\tvar.results.process = ctx.process_id();\n\tfor (t=var.job.start; t &lt; var.job.end; t++) {\n\t\tif (t &lt; 2) continue;\n\t\tint s;\n\t\ts = 2;\n\t\twhile( (s*s) &lt;= t) {\n\t\t\tif ((t % s) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts++;\n\t\t}\n\t\tif (s*s &gt; t) {\n\t\t\tvar.results.primes.push_back(t);\n\t\t}\n\t}\n</code><trace>fire</trace><verif-occurrence binding=\"True\" process=\"False\" /></transition><transition clock=\"False\" collective=\"False\" id=\"109\" label-x=\"127\" label-y=\"360\" name=\"write final results\" priority=\"\" sx=\"109\" sy=\"37\" x=\"92\" y=\"342\"><guard x=\"92\" y=\"322\" /><code>\n</code><trace>fire</trace><verif-occurrence binding=\"False\" process=\"True\" /></transition><edge from_item=\"103\" id=\"110\" to_item=\"107\"><inscription x=\"138.0\" y=\"192.0\">start</inscription></edge><edge from_item=\"107\" id=\"111\" to_item=\"103\"><inscription x=\"51.0\" y=\"88.0\">start + param::SIZE()</inscription><point x=\"37\" y=\"107\" /></edge><edge from_item=\"104\" id=\"112\" to_item=\"107\"><inscription x=\"224.0\" y=\"180.0\">results</inscription></edge><edge from_item=\"105\" id=\"113\" to_item=\"108\"><inscription x=\"424.0\" y=\"206.0\">job</inscription></edge><edge from_item=\"103\" id=\"114\" to_item=\"109\"><inscription x=\"1.0\" y=\"302.0\">param::LIMIT()</inscription></edge><edge from_item=\"104\" id=\"115\" to_item=\"109\"><inscription x=\"171.0\" y=\"301.0\">[bulk, guard(size == ctx.process_count() - 1 ) ]results</inscription></edge><edge from_item=\"108\" id=\"117\" to_item=\"104\"><inscription x=\"260.0\" y=\"258.0\">results@0</inscription></edge><edge from_item=\"107\" id=\"119\" to_item=\"105\"><inscription x=\"336.0\" y=\"88.0\">Job(start, start + param::SIZE())@results.process</inscription><point x=\"415\" y=\"107\" /></edge></net></project>");
	std::vector<ca::Parameter*> parameters;
	parameters.push_back(&param::LIMIT);
	parameters.push_back(&param::SIZE);

	cass::init(argc, argv, parameters, false);

	ca::NetDef *def_0 = new ca::NetDef(0, 0, spawn_0);
	def_0->register_transition(&transition_107);
	def_0->register_transition(&transition_108);
	def_0->register_transition(&transition_109);
	ca::NetDef *defs[] = {def_0};
	ca::setup(1, defs, false);
	VerifConfiguration verif_configuration;
	cass::Core core(argc, argv, verif_configuration, parameters);
	core.generate();
	core.postprocess();
	return 0;
}
#line 1 "*107/function"
void transition_user_fn_107(ca::Context &ctx, Vars_107 &var)
{
}
#line 1 "*108/function"
void transition_user_fn_108(ca::Context &ctx, Vars_108 &var)
{
	int t;
	var.results.process = ctx.process_id();
	for (t=var.job.start; t < var.job.end; t++) {
		if (t < 2) continue;
		int s;
		s = 2;
		while( (s*s) <= t) {
			if ((t % s) == 0) {
				break;
			}
			s++;
		}
		if (s*s > t) {
			var.results.primes.push_back(t);
		}
	}
}
#line 1 "*109/function"
void transition_user_fn_109(ca::Context &ctx, Vars_109 &var)
{
	ctx.quit();
}
#line 1 "*104/init_function"
void place_user_fn_104(ca::Context &ctx, ca::TokenList<Results > &place)
{
	for (int i = 1; i < ctx.process_count(); i++) {
		place.add(Results(i));
	}
}
