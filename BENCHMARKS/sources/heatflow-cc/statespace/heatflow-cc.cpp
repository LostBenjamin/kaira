/* This file is automatically generated
   do not edit this file directly! */

#include "heatflow-cc.h"
#include <caverif.h>
ca::ParameterInt param::SIZE_X("SIZE_X", "", ca::PARAMETER_MANDATORY);
ca::ParameterInt param::LIMIT("LIMIT", "", ca::PARAMETER_MANDATORY);
ca::ParameterInt param::SIZE_Y("SIZE_Y", "", ca::PARAMETER_MANDATORY);
ca::ParameterInt param::TEMP("TEMP", "", ca::PARAMETER_MANDATORY);
void place_user_fn_104(ca::Context &ctx, ca::TokenList<std::vector<double> > &place);
void place_user_fn_105(ca::Context &ctx, ca::TokenList<DoubleMatrix > &place);
void place_user_fn_106(ca::Context &ctx, ca::TokenList<std::vector<double> > &place);
class Tokens_111  : public ca::Binding {
	public:
	Tokens_111() {};
	Tokens_111(const Tokens_111 &t) {
		blocked = t.blocked;
		root = t.root;
		if (t.token_collective != NULL) {
			token_collective = new ca::Token<std::vector<DoubleMatrix> >(t.token_collective->value);
		} else {
			token_collective = NULL;
		}
		if (t.token_1001 != NULL) {
			token_1001 = new ca::Token<int >(t.token_1001->value);
		} else {
			token_1001 = NULL;
		}
		if (t.token_1003 != NULL) {
			token_1003 = new ca::Token<DoubleMatrix >(t.token_1003->value);
		} else {
			token_1003 = NULL;
		}
	}
	Tokens_111& operator=(const Tokens_111 &t) {
		if (this != &t) {
			blocked = t.blocked;
			root = t.root;
			if (t.token_collective != NULL) {
				delete token_collective;
				token_collective = new ca::Token<std::vector<DoubleMatrix> >(t.token_collective->value);
			} else {
				token_collective = NULL;
			}
			if (t.token_1001 != NULL) {
				delete token_1001;
				token_1001 = new ca::Token<int >(t.token_1001->value);
			} else {
				token_1001 = NULL;
			}
			if (t.token_1003 != NULL) {
				delete token_1003;
				token_1003 = new ca::Token<DoubleMatrix >(t.token_1003->value);
			} else {
				token_1003 = NULL;
			}
		}
		return *this;
	}
	~Tokens_111() {
		if (token_collective != NULL) {
			delete token_collective;
		}
		if (token_1001 != NULL) {
			delete token_1001;
		}
		if (token_1003 != NULL) {
			delete token_1003;
		}
	}
	ca::Binding* copy() {
		Tokens_111 *t = new Tokens_111(*this);
		return t;
	}
	bool blocked;
	int root;
	ca::Token<std::vector<DoubleMatrix> > *token_collective;
	ca::Token<int > *token_1001;
	ca::Token<DoubleMatrix > *token_1003;
};
class Transition_111  : public ca::TransitionDef {
	public:
	Transition_111() : ca::TransitionDef(111, "Send \nresults", ca::TRANSITION_COLLECTIVE, 0) {
	}
	ca::FireResult full_fire(ca::ThreadBase *thread, ca::NetBase *net);
	ca::Binding* fire_phase1(ca::ThreadBase *thread, ca::NetBase *net);
	void fire_phase2(ca::ThreadBase *thread, ca::NetBase *net, ca::Binding *data);
	bool is_enable(ca::ThreadBase *thread, ca::NetBase *net);
	bool is_blocked(ca::Binding *data);
	void pack_binding(ca::Packer &packer, ca::Binding *data);
	ca::Binding* unpack_binding(ca::Unpacker &unpacker);
	ca::FireResult full_fire_with_binding(ca::ThreadBase *thread, ca::NetBase *net, ca::Packer &__kaira__packer);
};
static Transition_111 transition_111;

class Vars_112 {
	public:
	Vars_112(ca::Context &ctx,std::vector<DoubleMatrix> &results) : ctx(ctx),results(results) {
	}
	ca::Context &ctx;
	std::vector<DoubleMatrix> &results;
};
void transition_user_fn_112(ca::Context &ctx, Vars_112 &var);
class Tokens_112  : public ca::Binding {
	public:
	Tokens_112() {};
	Tokens_112(const Tokens_112 &t) {
		if (t.token_1007 != NULL) {
			token_1007 = new ca::Token<std::vector<DoubleMatrix> >(t.token_1007->value);
		} else {
			token_1007 = NULL;
		}
	}
	Tokens_112& operator=(const Tokens_112 &t) {
		if (this != &t) {
			if (t.token_1007 != NULL) {
				delete token_1007;
				token_1007 = new ca::Token<std::vector<DoubleMatrix> >(t.token_1007->value);
			} else {
				token_1007 = NULL;
			}
		}
		return *this;
	}
	~Tokens_112() {
		if (token_1007 != NULL) {
			delete token_1007;
		}
	}
	ca::Binding* copy() {
		Tokens_112 *t = new Tokens_112(*this);
		return t;
	}
	ca::Token<std::vector<DoubleMatrix> > *token_1007;
};
class Transition_112  : public ca::TransitionDef {
	public:
	Transition_112() : ca::TransitionDef(112, "Write results", ca::TRANSITION_NORMAL, 0) {
	}
	ca::FireResult full_fire(ca::ThreadBase *thread, ca::NetBase *net);
	ca::Binding* fire_phase1(ca::ThreadBase *thread, ca::NetBase *net);
	void fire_phase2(ca::ThreadBase *thread, ca::NetBase *net, ca::Binding *data);
	bool is_enable(ca::ThreadBase *thread, ca::NetBase *net);
	void pack_binding(ca::Packer &packer, ca::Binding *data);
	ca::Binding* unpack_binding(ca::Unpacker &unpacker);
	ca::FireResult full_fire_with_binding(ca::ThreadBase *thread, ca::NetBase *net, ca::Packer &__kaira__packer);
};
static Transition_112 transition_112;

class Vars_110 {
	public:
	Vars_110(int &c,ca::Context &ctx,DoubleMatrix &data,std::vector<double> &down,std::vector<double> &up) : c(c),ctx(ctx),data(data),down(down),up(up) {
	}
	int &c;
	ca::Context &ctx;
	DoubleMatrix &data;
	std::vector<double> &down;
	std::vector<double> &up;
};
void transition_user_fn_110(ca::Context &ctx, Vars_110 &var);
class Tokens_110  : public ca::Binding {
	public:
	Tokens_110() {};
	Tokens_110(const Tokens_110 &t) {
		if (t.token_1009 != NULL) {
			token_1009 = new ca::Token<std::vector<double> >(t.token_1009->value);
		} else {
			token_1009 = NULL;
		}
		if (t.token_1011 != NULL) {
			token_1011 = new ca::Token<int >(t.token_1011->value);
		} else {
			token_1011 = NULL;
		}
		if (t.token_1013 != NULL) {
			token_1013 = new ca::Token<std::vector<double> >(t.token_1013->value);
		} else {
			token_1013 = NULL;
		}
		if (t.token_1015 != NULL) {
			token_1015 = new ca::Token<DoubleMatrix >(t.token_1015->value);
		} else {
			token_1015 = NULL;
		}
	}
	Tokens_110& operator=(const Tokens_110 &t) {
		if (this != &t) {
			if (t.token_1009 != NULL) {
				delete token_1009;
				token_1009 = new ca::Token<std::vector<double> >(t.token_1009->value);
			} else {
				token_1009 = NULL;
			}
			if (t.token_1011 != NULL) {
				delete token_1011;
				token_1011 = new ca::Token<int >(t.token_1011->value);
			} else {
				token_1011 = NULL;
			}
			if (t.token_1013 != NULL) {
				delete token_1013;
				token_1013 = new ca::Token<std::vector<double> >(t.token_1013->value);
			} else {
				token_1013 = NULL;
			}
			if (t.token_1015 != NULL) {
				delete token_1015;
				token_1015 = new ca::Token<DoubleMatrix >(t.token_1015->value);
			} else {
				token_1015 = NULL;
			}
		}
		return *this;
	}
	~Tokens_110() {
		if (token_1009 != NULL) {
			delete token_1009;
		}
		if (token_1011 != NULL) {
			delete token_1011;
		}
		if (token_1013 != NULL) {
			delete token_1013;
		}
		if (token_1015 != NULL) {
			delete token_1015;
		}
	}
	ca::Binding* copy() {
		Tokens_110 *t = new Tokens_110(*this);
		return t;
	}
	ca::Token<std::vector<double> > *token_1009;
	ca::Token<int > *token_1011;
	ca::Token<std::vector<double> > *token_1013;
	ca::Token<DoubleMatrix > *token_1015;
};
class Transition_110  : public ca::TransitionDef {
	public:
	Transition_110() : ca::TransitionDef(110, "Compute", ca::TRANSITION_NORMAL, 0) {
	}
	ca::FireResult full_fire(ca::ThreadBase *thread, ca::NetBase *net);
	ca::Binding* fire_phase1(ca::ThreadBase *thread, ca::NetBase *net);
	void fire_phase2(ca::ThreadBase *thread, ca::NetBase *net, ca::Binding *data);
	bool is_enable(ca::ThreadBase *thread, ca::NetBase *net);
	void pack_binding(ca::Packer &packer, ca::Binding *data);
	ca::Binding* unpack_binding(ca::Unpacker &unpacker);
	ca::FireResult full_fire_with_binding(ca::ThreadBase *thread, ca::NetBase *net, ca::Packer &__kaira__packer);
};
static Transition_110 transition_110;

class Net_101  : public cass::Net {
	public:
	ca::NetBase * copy() {
		Net_101 *net = new Net_101(*this);
		return net;
	}
	ca::Place<std::vector<double> > place_104;
	ca::Place<DoubleMatrix > place_105;
	ca::Place<std::vector<double> > place_106;
	ca::Place<int > place_107;
	ca::Place<std::vector<DoubleMatrix> > place_108;
	void write_reports_content(ca::ThreadBase *thread, ca::Output &output) {
		output.child("place");
		output.set("id", 104);
		{
			ca::Token<std::vector<double> > *t = place_104.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_104.begin());
			}
		}
		output.back();
		output.child("place");
		output.set("id", 105);
		{
			ca::Token<DoubleMatrix > *t = place_105.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_105.begin());
			}
		}
		output.back();
		output.child("place");
		output.set("id", 106);
		{
			ca::Token<std::vector<double> > *t = place_106.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_106.begin());
			}
		}
		output.back();
		output.child("place");
		output.set("id", 107);
		{
			ca::Token<int > *t = place_107.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_107.begin());
			}
		}
		output.back();
		output.child("place");
		output.set("id", 108);
		{
			ca::Token<std::vector<DoubleMatrix> > *t = place_108.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_108.begin());
			}
		}
		output.back();
	}
	void receive(ca::ThreadBase *__kaira__thread, int from_process, int place_pos, ca::Unpacker &unpacker) {
		switch(place_pos) {
		case 119:
		{
			ca::Token<std::vector<double> > *token = new ca::Token<std::vector<double> >();
			ca::unpack(unpacker, token->value);
			this->place_106.add_token(token);
			this->activate_transition_by_pos_id(2);
		}
		break;
		case 117:
		{
			ca::Token<std::vector<double> > *token = new ca::Token<std::vector<double> >();
			ca::unpack(unpacker, token->value);
			this->place_104.add_token(token);
			this->activate_transition_by_pos_id(2);
		}
		break;
		}
	}
	void pack(ca::Packer &packer) {
		ca::pack(packer, place_104);
		ca::pack(packer, place_105);
		ca::pack(packer, place_106);
		ca::pack(packer, place_107);
		ca::pack(packer, place_108);
	}
	void unpack(ca::Unpacker &unpacker) {
		ca::unpack(unpacker, place_104);
		ca::unpack(unpacker, place_105);
		ca::unpack(unpacker, place_106);
		ca::unpack(unpacker, place_107);
		ca::unpack(unpacker, place_108);
	}
	size_t get_token_count_in_place(int place_id) {
		if (place_id == 104) return this->place_104.size();
		if (place_id == 105) return this->place_105.size();
		if (place_id == 106) return this->place_106.size();
		if (place_id == 107) return this->place_107.size();
		if (place_id == 108) return this->place_108.size();
		return 0;
	}
};
ca::NetBase * spawn_101(ca::ThreadBase *__kaira__thread, ca::NetDef *__kaira__def) {
	Net_101 *__kaira__net = new Net_101();
	ca::Context ctx(__kaira__thread, __kaira__net);
	int __kaira__pid = __kaira__thread->get_process_id();
	std::vector<int> __kaira__area_102 = ctx.all_processes();
	if (std::find(__kaira__area_102.begin(), __kaira__area_102.end(), __kaira__pid) != __kaira__area_102.end()) {
		{
			ca::TokenList<std::vector<double> > __kaira__list;
			place_user_fn_104(ctx, __kaira__list);
			__kaira__net->place_104.overtake(__kaira__list);
		}
	}
	if (std::find(__kaira__area_102.begin(), __kaira__area_102.end(), __kaira__pid) != __kaira__area_102.end()) {
		{
			ca::TokenList<DoubleMatrix > __kaira__list;
			place_user_fn_105(ctx, __kaira__list);
			__kaira__net->place_105.overtake(__kaira__list);
		}
	}
	if (std::find(__kaira__area_102.begin(), __kaira__area_102.end(), __kaira__pid) != __kaira__area_102.end()) {
		{
			ca::TokenList<std::vector<double> > __kaira__list;
			place_user_fn_106(ctx, __kaira__list);
			__kaira__net->place_106.overtake(__kaira__list);
		}
	}
	if (std::find(__kaira__area_102.begin(), __kaira__area_102.end(), __kaira__pid) != __kaira__area_102.end()) {
		__kaira__net->place_107.add(0);
	}
	return __kaira__net;
}
ca::FireResult Transition_111::full_fire(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_107.size() < 1) return ca::NOT_ENABLED;
	if (__kaira__n->place_105.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=126 uid=1001 expr=param::LIMIT()
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_107.begin();
	if (!((__kaira__token_1001->value) == (param::LIMIT()))) {
		return ca::NOT_ENABLED;
	}
	// Inscription id=126 uid=1003 expr=data
	ca::Token < DoubleMatrix > *__kaira__token_1003;
	__kaira__token_1003 = __kaira__n->place_105.begin();
	DoubleMatrix &data = __kaira__token_1003->value;
	if (__kaira__token_1001->value != (param::LIMIT())) {
		return ca::NOT_ENABLED;
	}
	int __kaira__root = 0;
	{
		{
			__kaira__n->place_107.remove(__kaira__token_1001);
			__kaira__n->place_105.remove(__kaira__token_1003);
		}
		__kaira__n->activate_transition_by_pos_id(0);
		if (__kaira__root == __kaira__thread->get_process_id()) {
			ca::Token<std::vector<DoubleMatrix > > *__kaira__token = new ca::Token<std::vector<DoubleMatrix > >;
			if (ca::is_trivially_packable<DoubleMatrix >()) {
				const size_t __kaira__size = sizeof(DoubleMatrix);
				__kaira__token->value.resize(__kaira__thread->get_process_count());
				__kaira__thread->collective_gather_root(111, &data, __kaira__size, &__kaira__token->value[0]);
			} else if (ca::fixed_size<DoubleMatrix >() != 0) {
				const size_t __kaira__size = ca::fixed_size<DoubleMatrix >();
				ca::Packer __kaira__packer(__kaira__size);
				__kaira__packer << data;
				if (__kaira__packer.get_size() > __kaira__size) {
					fprintf(stderr, "Type 'DoubleMatrix' has fixed size %zu,but %zu bytes was packed.\n", __kaira__size, __kaira__packer.get_size());
					exit(1);
				}
				void *__kaira__mem = malloc(__kaira__size * __kaira__thread->get_process_count());
				__kaira__thread->collective_gather_root(111, __kaira__packer.get_buffer(), __kaira__size, __kaira__mem);
				__kaira__packer.free();
				ca::Unpacker __kaira__unpacker(__kaira__mem, __kaira__size * __kaira__thread->get_process_count());
				ca::unpack_with_step(__kaira__unpacker,__kaira__token->value, __kaira__size, __kaira__thread->get_process_count());
				free(__kaira__mem);
			} else {
				int __kaira__process_count = __kaira__thread->get_process_count();
				int *__kaira__sizes = static_cast<int*>(alloca(sizeof(int) * __kaira__process_count));
				int *__kaira__displs = static_cast<int*>(alloca(sizeof(int) * (1 + __kaira__process_count)));
				int __kaira__size = 0;
				__kaira__thread->collective_gather_root(111, &__kaira__size, sizeof(int), __kaira__sizes);
				__kaira__displs[0] = 0;
				for (int __kaira__i = 0; __kaira__i < ca::process_count; __kaira__i++) {
					__kaira__displs[__kaira__i + 1] = __kaira__displs[__kaira__i] + __kaira__sizes[__kaira__i];
				}
				void *__kaira__mem = malloc(__kaira__displs[__kaira__process_count]);
				__kaira__thread->collective_gatherv_root(111, &__kaira__size, 0, __kaira__mem, __kaira__sizes, __kaira__displs);
				ca::Unpacker __kaira__unpacker(__kaira__mem, __kaira__displs[__kaira__process_count]);
				int __kaira__process_id = __kaira__thread->get_process_id();
				ca::unpack_with_displs(__kaira__unpacker, __kaira__token->value, __kaira__process_id, __kaira__displs);
				__kaira__token->value.push_back(data);
				ca::unpack_with_displs(__kaira__unpacker, __kaira__token->value, __kaira__process_count - __kaira__process_id - 1,__kaira__displs + __kaira__process_id + 1);
				free(__kaira__mem);
			}
			__kaira__n->place_108.add_token(__kaira__token);
			__kaira__n->activate_transition_by_pos_id(1);
		} else {
			if (ca::is_trivially_packable<DoubleMatrix >()) {
				__kaira__thread->collective_gather_nonroot(111, __kaira__root, &data, sizeof(DoubleMatrix));
			} else if (ca::fixed_size<DoubleMatrix >() != 0) {
				const size_t __kaira__size = ca::fixed_size<DoubleMatrix >();
				ca::Packer __kaira__packer(__kaira__size);
				__kaira__packer << data;
				if (__kaira__packer.get_size() > __kaira__size) {
					fprintf(stderr, "Type 'DoubleMatrix' has fixed size %zu,but %zu bytes was packed.\n", __kaira__size, __kaira__packer.get_size());
					exit(1);
				}
				__kaira__thread->collective_gather_nonroot(111, __kaira__root, __kaira__packer.get_buffer(), __kaira__size);
				__kaira__packer.free();
			} else {
				ca::Packer __kaira__packer;
				__kaira__packer << data;
				int __kaira__size = __kaira__packer.get_size();
				__kaira__thread->collective_gather_nonroot(111, __kaira__root, &__kaira__size, sizeof(int));
				__kaira__thread->collective_gatherv_nonroot(111, __kaira__root, __kaira__packer.get_buffer(), __kaira__packer.get_size());
				__kaira__packer.free();
			}
		}
		delete __kaira__token_1001;
		delete __kaira__token_1003;
		return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::Binding* Transition_111::fire_phase1(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_107.size() < 1) return NULL;
	if (__kaira__n->place_105.size() < 1) return NULL;
	// Inscription id=126 uid=1001 expr=param::LIMIT()
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_107.begin();
	if (!((__kaira__token_1001->value) == (param::LIMIT()))) {
		return NULL;
	}
	// Inscription id=126 uid=1003 expr=data
	ca::Token < DoubleMatrix > *__kaira__token_1003;
	__kaira__token_1003 = __kaira__n->place_105.begin();
	DoubleMatrix &data = __kaira__token_1003->value;
	if (__kaira__token_1001->value != (param::LIMIT())) {
		return NULL;
	}
	int __kaira__root = 0;
	{
		{
			__kaira__n->place_107.remove(__kaira__token_1001);
			__kaira__n->place_105.remove(__kaira__token_1003);
		}
		Tokens_111 *__kaira__tokens = new Tokens_111();
		__kaira__tokens->token_1001 = __kaira__token_1001;
		__kaira__tokens->token_1003 = __kaira__token_1003;
		__kaira__tokens->blocked = true;
		__kaira__tokens->root = __kaira__root;
		__kaira__tokens->token_collective = NULL;
		std::vector<ca::Binding*> __kaira__bindings;
		int __kaira__bcount = __kaira__thread->collective_bindings(this, __kaira__bindings);
		int __kaira__process_count = __kaira__thread->get_process_count();
		if (__kaira__root < 0 || __kaira__root >= __kaira__process_count) {
			fprintf(stderr, "Collective transition started with invalid root; root=%i at process %i \n",__kaira__root, __kaira__thread->get_process_id());
			exit(1);
		}
		for (int __kaira__i = 0; __kaira__i < __kaira__thread->get_process_count(); __kaira__i++) {
			Tokens_111 *__kaira__t = static_cast<Tokens_111*>(__kaira__bindings[__kaira__i]);
			if (__kaira__t && __kaira__t->root != __kaira__root) {
				fprintf(stderr, "Collective transition started with different roots; root=%i at process %i and root=%i at process %i\n",__kaira__root, __kaira__thread->get_process_id(), __kaira__t->root, __kaira__i);
				exit(1);
			}
		}
		if (__kaira__bcount == __kaira__thread->get_process_count() - 1) {
			__kaira__bindings[__kaira__thread->get_process_id()] = __kaira__tokens;
			const size_t __kaira__size = sizeof(DoubleMatrix);
			Tokens_111 *__kaira__rbinding = static_cast<Tokens_111*>(__kaira__bindings[__kaira__root]);
			__kaira__rbinding->token_collective = new ca::Token<std::vector<DoubleMatrix> >;
			__kaira__rbinding->token_collective->value.resize(__kaira__thread->get_process_count());
			for (int __kaira__i = 0; __kaira__i < __kaira__thread->get_process_count(); __kaira__i++) {
				Tokens_111 *__kaira__t = static_cast<Tokens_111*>(__kaira__bindings[__kaira__i]);
				__kaira__t->blocked = false;
				ca::Token<int > *__kaira__token_1001 = static_cast<Tokens_111*>(__kaira__bindings[__kaira__i])->token_1001;
				ca::Token<DoubleMatrix > *__kaira__token_1003 = static_cast<Tokens_111*>(__kaira__bindings[__kaira__i])->token_1003;
				int __kaira__root = static_cast<Tokens_111*>(__kaira__bindings[__kaira__i])->root;
				DoubleMatrix &data = __kaira__token_1003->value;
				__kaira__rbinding->token_collective->value[__kaira__i] = data;
			}
		}
		return __kaira__tokens;
	}
	return NULL;
}
void Transition_111::fire_phase2(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Binding *__kaira__binding)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	Tokens_111 *__kaira__tokens = static_cast<Tokens_111*>(__kaira__binding);
	ca::Token<int > *__kaira__token_1001 = __kaira__tokens->token_1001;
	ca::Token<DoubleMatrix > *__kaira__token_1003 = __kaira__tokens->token_1003;
	int __kaira__root = __kaira__tokens->root;
	DoubleMatrix &data = __kaira__token_1003->value;
	__kaira__n->activate_transition_by_pos_id(0);
	if (__kaira__root == __kaira__thread->get_process_id()) {
		__kaira__n->place_108.add_token(__kaira__tokens->token_collective);
	}
	__kaira__tokens->token_collective = NULL;
	delete __kaira__binding;
}
bool Transition_111::is_enable(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_107.size() < 1) return false;
	if (__kaira__n->place_105.size() < 1) return false;
	// Inscription id=126 uid=1001 expr=param::LIMIT()
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_107.begin();
	if (!((__kaira__token_1001->value) == (param::LIMIT()))) {
		return false;
	}
	// Inscription id=126 uid=1003 expr=data
	ca::Token < DoubleMatrix > *__kaira__token_1003;
	__kaira__token_1003 = __kaira__n->place_105.begin();
	DoubleMatrix &data = __kaira__token_1003->value;
	if (__kaira__token_1001->value != (param::LIMIT())) {
		return false;
	}
	int __kaira__root = 0;
	{
		return true;
	}
	return false;
}
void Transition_111::pack_binding(ca::Packer &packer, ca::Binding *binding)
{
	Tokens_111 *tokens = static_cast<Tokens_111*>(binding);
	ca::pack(packer, tokens->blocked);
	ca::pack(packer, tokens->root);
	ca::pack(packer, tokens->token_collective != NULL);
	if (tokens->token_collective) {
		ca::pack(packer, tokens->token_collective->value);
	}
	ca::pack(packer, tokens->token_1001->value);
	ca::pack(packer, tokens->token_1003->value);
}
ca::Binding* Transition_111::unpack_binding(ca::Unpacker &unpacker)
{
	Tokens_111 *tokens = new Tokens_111;
	ca::unpack(unpacker, tokens->blocked);
	ca::unpack(unpacker, tokens->root);
	bool __kaira__collective;
	ca::unpack(unpacker, __kaira__collective);
	if (__kaira__collective) {
		tokens->token_collective = new ca::Token<std::vector<DoubleMatrix> >;
		ca::unpack(unpacker, tokens->token_collective->value);
	} else {
		tokens->token_collective = NULL;
	}
	tokens->token_1001 = new ca::Token<int >;
	ca::unpack(unpacker, tokens->token_1001->value);
	tokens->token_1003 = new ca::Token<DoubleMatrix >;
	ca::unpack(unpacker, tokens->token_1003->value);
	return tokens;
}
ca::FireResult Transition_111::full_fire_with_binding(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Packer &__kaira__packer)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_107.size() < 1) return ca::NOT_ENABLED;
	if (__kaira__n->place_105.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=126 uid=1001 expr=param::LIMIT()
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_107.begin();
	if (!((__kaira__token_1001->value) == (param::LIMIT()))) {
		return ca::NOT_ENABLED;
	}
	// Inscription id=126 uid=1003 expr=data
	ca::Token < DoubleMatrix > *__kaira__token_1003;
	__kaira__token_1003 = __kaira__n->place_105.begin();
	DoubleMatrix &data = __kaira__token_1003->value;
	if (__kaira__token_1001->value != (param::LIMIT())) {
		return ca::NOT_ENABLED;
	}
	int __kaira__root = 0;
	{
		ca::pack(__kaira__packer, __kaira__token_1001->value);
		ca::pack(__kaira__packer, __kaira__token_1003->value);
		{
			__kaira__n->place_107.remove(__kaira__token_1001);
			__kaira__n->place_105.remove(__kaira__token_1003);
		}
		__kaira__n->activate_transition_by_pos_id(0);
		if (__kaira__root == __kaira__thread->get_process_id()) {
			ca::Token<std::vector<DoubleMatrix > > *__kaira__token = new ca::Token<std::vector<DoubleMatrix > >;
			if (ca::is_trivially_packable<DoubleMatrix >()) {
				const size_t __kaira__size = sizeof(DoubleMatrix);
				__kaira__token->value.resize(__kaira__thread->get_process_count());
				__kaira__thread->collective_gather_root(111, &data, __kaira__size, &__kaira__token->value[0]);
			} else if (ca::fixed_size<DoubleMatrix >() != 0) {
				const size_t __kaira__size = ca::fixed_size<DoubleMatrix >();
				ca::Packer __kaira__packer(__kaira__size);
				__kaira__packer << data;
				if (__kaira__packer.get_size() > __kaira__size) {
					fprintf(stderr, "Type 'DoubleMatrix' has fixed size %zu,but %zu bytes was packed.\n", __kaira__size, __kaira__packer.get_size());
					exit(1);
				}
				void *__kaira__mem = malloc(__kaira__size * __kaira__thread->get_process_count());
				__kaira__thread->collective_gather_root(111, __kaira__packer.get_buffer(), __kaira__size, __kaira__mem);
				__kaira__packer.free();
				ca::Unpacker __kaira__unpacker(__kaira__mem, __kaira__size * __kaira__thread->get_process_count());
				ca::unpack_with_step(__kaira__unpacker,__kaira__token->value, __kaira__size, __kaira__thread->get_process_count());
				free(__kaira__mem);
			} else {
				int __kaira__process_count = __kaira__thread->get_process_count();
				int *__kaira__sizes = static_cast<int*>(alloca(sizeof(int) * __kaira__process_count));
				int *__kaira__displs = static_cast<int*>(alloca(sizeof(int) * (1 + __kaira__process_count)));
				int __kaira__size = 0;
				__kaira__thread->collective_gather_root(111, &__kaira__size, sizeof(int), __kaira__sizes);
				__kaira__displs[0] = 0;
				for (int __kaira__i = 0; __kaira__i < ca::process_count; __kaira__i++) {
					__kaira__displs[__kaira__i + 1] = __kaira__displs[__kaira__i] + __kaira__sizes[__kaira__i];
				}
				void *__kaira__mem = malloc(__kaira__displs[__kaira__process_count]);
				__kaira__thread->collective_gatherv_root(111, &__kaira__size, 0, __kaira__mem, __kaira__sizes, __kaira__displs);
				ca::Unpacker __kaira__unpacker(__kaira__mem, __kaira__displs[__kaira__process_count]);
				int __kaira__process_id = __kaira__thread->get_process_id();
				ca::unpack_with_displs(__kaira__unpacker, __kaira__token->value, __kaira__process_id, __kaira__displs);
				__kaira__token->value.push_back(data);
				ca::unpack_with_displs(__kaira__unpacker, __kaira__token->value, __kaira__process_count - __kaira__process_id - 1,__kaira__displs + __kaira__process_id + 1);
				free(__kaira__mem);
			}
			__kaira__n->place_108.add_token(__kaira__token);
			__kaira__n->activate_transition_by_pos_id(1);
		} else {
			if (ca::is_trivially_packable<DoubleMatrix >()) {
				__kaira__thread->collective_gather_nonroot(111, __kaira__root, &data, sizeof(DoubleMatrix));
			} else if (ca::fixed_size<DoubleMatrix >() != 0) {
				const size_t __kaira__size = ca::fixed_size<DoubleMatrix >();
				ca::Packer __kaira__packer(__kaira__size);
				__kaira__packer << data;
				if (__kaira__packer.get_size() > __kaira__size) {
					fprintf(stderr, "Type 'DoubleMatrix' has fixed size %zu,but %zu bytes was packed.\n", __kaira__size, __kaira__packer.get_size());
					exit(1);
				}
				__kaira__thread->collective_gather_nonroot(111, __kaira__root, __kaira__packer.get_buffer(), __kaira__size);
				__kaira__packer.free();
			} else {
				ca::Packer __kaira__packer;
				__kaira__packer << data;
				int __kaira__size = __kaira__packer.get_size();
				__kaira__thread->collective_gather_nonroot(111, __kaira__root, &__kaira__size, sizeof(int));
				__kaira__thread->collective_gatherv_nonroot(111, __kaira__root, __kaira__packer.get_buffer(), __kaira__packer.get_size());
				__kaira__packer.free();
			}
		}
		delete __kaira__token_1001;
		delete __kaira__token_1003;
		return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
bool Transition_111::is_blocked(ca::Binding *binding)
{
	Tokens_111 *tokens = static_cast<Tokens_111*>(binding);
	return tokens->blocked;
}
ca::FireResult Transition_112::full_fire(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_108.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=123 uid=1007 expr=results
	ca::Token < std::vector<DoubleMatrix> > *__kaira__token_1007;
	__kaira__token_1007 = __kaira__n->place_108.begin();
	std::vector<DoubleMatrix> &results = __kaira__token_1007->value;
	{
		{
			__kaira__n->place_108.remove(__kaira__token_1007);
		}
		__kaira__n->activate_transition_by_pos_id(1);
		Vars_112 __kaira__vars(ctx,results);
		transition_user_fn_112(ctx, __kaira__vars);
		delete __kaira__token_1007;
		return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::Binding* Transition_112::fire_phase1(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_108.size() < 1) return NULL;
	// Inscription id=123 uid=1007 expr=results
	ca::Token < std::vector<DoubleMatrix> > *__kaira__token_1007;
	__kaira__token_1007 = __kaira__n->place_108.begin();
	std::vector<DoubleMatrix> &results = __kaira__token_1007->value;
	{
		{
			__kaira__n->place_108.remove(__kaira__token_1007);
		}
		Tokens_112 *__kaira__tokens = new Tokens_112();
		__kaira__tokens->token_1007 = __kaira__token_1007;
		return __kaira__tokens;
	}
	return NULL;
}
void Transition_112::fire_phase2(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Binding *__kaira__binding)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	Tokens_112 *__kaira__tokens = static_cast<Tokens_112*>(__kaira__binding);
	ca::Token<std::vector<DoubleMatrix> > *__kaira__token_1007 = __kaira__tokens->token_1007;
	std::vector<DoubleMatrix> &results = __kaira__token_1007->value;
	__kaira__n->activate_transition_by_pos_id(1);
	Vars_112 __kaira__vars(ctx,results);
	transition_user_fn_112(ctx, __kaira__vars);
	delete __kaira__binding;
}
bool Transition_112::is_enable(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_108.size() < 1) return false;
	// Inscription id=123 uid=1007 expr=results
	ca::Token < std::vector<DoubleMatrix> > *__kaira__token_1007;
	__kaira__token_1007 = __kaira__n->place_108.begin();
	std::vector<DoubleMatrix> &results = __kaira__token_1007->value;
	{
		return true;
	}
	return false;
}
void Transition_112::pack_binding(ca::Packer &packer, ca::Binding *binding)
{
	Tokens_112 *tokens = static_cast<Tokens_112*>(binding);
	ca::pack(packer, tokens->token_1007->value);
}
ca::Binding* Transition_112::unpack_binding(ca::Unpacker &unpacker)
{
	Tokens_112 *tokens = new Tokens_112;
	tokens->token_1007 = new ca::Token<std::vector<DoubleMatrix> >;
	ca::unpack(unpacker, tokens->token_1007->value);
	return tokens;
}
ca::FireResult Transition_112::full_fire_with_binding(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Packer &__kaira__packer)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_108.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=123 uid=1007 expr=results
	ca::Token < std::vector<DoubleMatrix> > *__kaira__token_1007;
	__kaira__token_1007 = __kaira__n->place_108.begin();
	std::vector<DoubleMatrix> &results = __kaira__token_1007->value;
	{
		ca::pack(__kaira__packer, __kaira__token_1007->value);
		{
			__kaira__n->place_108.remove(__kaira__token_1007);
		}
		__kaira__n->activate_transition_by_pos_id(1);
		Vars_112 __kaira__vars(ctx,results);
		transition_user_fn_112(ctx, __kaira__vars);
		delete __kaira__token_1007;
		return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::FireResult Transition_110::full_fire(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_104.size() < 1) return ca::NOT_ENABLED;
	if (__kaira__n->place_107.size() < 1) return ca::NOT_ENABLED;
	if (__kaira__n->place_106.size() < 1) return ca::NOT_ENABLED;
	if (__kaira__n->place_105.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=118 uid=1009 expr=down
	ca::Token < std::vector<double> > *__kaira__token_1009;
	__kaira__token_1009 = __kaira__n->place_104.begin();
	std::vector<double> &down = __kaira__token_1009->value;
	// Inscription id=118 uid=1011 expr=c
	ca::Token < int > *__kaira__token_1011;
	__kaira__token_1011 = __kaira__n->place_107.begin();
	int &c = __kaira__token_1011->value;
	// Inscription id=118 uid=1013 expr=up
	ca::Token < std::vector<double> > *__kaira__token_1013;
	__kaira__token_1013 = __kaira__n->place_106.begin();
	std::vector<double> &up = __kaira__token_1013->value;
	// Inscription id=118 uid=1015 expr=data
	ca::Token < DoubleMatrix > *__kaira__token_1015;
	__kaira__token_1015 = __kaira__n->place_105.begin();
	DoubleMatrix &data = __kaira__token_1015->value;
	if (!(c < param::LIMIT())) {
		return ca::NOT_ENABLED;
	}
	{
		{
			__kaira__n->place_104.remove(__kaira__token_1009);
			__kaira__n->place_107.remove(__kaira__token_1011);
			__kaira__n->place_106.remove(__kaira__token_1013);
			__kaira__n->place_105.remove(__kaira__token_1015);
		}
		__kaira__n->activate_transition_by_pos_id(2);
		Vars_110 __kaira__vars(c,ctx,data,down,up);
		transition_user_fn_110(ctx, __kaira__vars);
		__kaira__n->place_107.add(c+1);
		__kaira__n->activate_transition_by_pos_id(0);
		__kaira__n->activate_transition_by_pos_id(2);
		if (to_down(ctx) == __kaira__thread->get_process_id()) {
			__kaira__n->place_106.add(down);
			__kaira__n->activate_transition_by_pos_id(2);
		} else {
			int __kaira__target = to_down(ctx);
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (down));
				__kaira__thread->send(__kaira__target, __kaira__n, 119, 1, __kaira__packer);
			}
			if (to_up(ctx) == __kaira__thread->get_process_id()) {
				__kaira__n->place_104.add(up);
				__kaira__n->activate_transition_by_pos_id(2);
		} else {
			int __kaira__target = to_up(ctx);
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (up));
				__kaira__thread->send(__kaira__target, __kaira__n, 117, 1, __kaira__packer);
			}
			__kaira__n->place_105.add_token(__kaira__token_1015);
			__kaira__n->activate_transition_by_pos_id(0);
			__kaira__n->activate_transition_by_pos_id(2);
			delete __kaira__token_1009;
			delete __kaira__token_1011;
			delete __kaira__token_1013;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::Binding* Transition_110::fire_phase1(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_104.size() < 1) return NULL;
	if (__kaira__n->place_107.size() < 1) return NULL;
	if (__kaira__n->place_106.size() < 1) return NULL;
	if (__kaira__n->place_105.size() < 1) return NULL;
	// Inscription id=118 uid=1009 expr=down
	ca::Token < std::vector<double> > *__kaira__token_1009;
	__kaira__token_1009 = __kaira__n->place_104.begin();
	std::vector<double> &down = __kaira__token_1009->value;
	// Inscription id=118 uid=1011 expr=c
	ca::Token < int > *__kaira__token_1011;
	__kaira__token_1011 = __kaira__n->place_107.begin();
	int &c = __kaira__token_1011->value;
	// Inscription id=118 uid=1013 expr=up
	ca::Token < std::vector<double> > *__kaira__token_1013;
	__kaira__token_1013 = __kaira__n->place_106.begin();
	std::vector<double> &up = __kaira__token_1013->value;
	// Inscription id=118 uid=1015 expr=data
	ca::Token < DoubleMatrix > *__kaira__token_1015;
	__kaira__token_1015 = __kaira__n->place_105.begin();
	DoubleMatrix &data = __kaira__token_1015->value;
	if (!(c < param::LIMIT())) {
		return NULL;
	}
	{
		{
			__kaira__n->place_104.remove(__kaira__token_1009);
			__kaira__n->place_107.remove(__kaira__token_1011);
			__kaira__n->place_106.remove(__kaira__token_1013);
			__kaira__n->place_105.remove(__kaira__token_1015);
		}
		Tokens_110 *__kaira__tokens = new Tokens_110();
		__kaira__tokens->token_1009 = __kaira__token_1009;
		__kaira__tokens->token_1011 = __kaira__token_1011;
		__kaira__tokens->token_1013 = __kaira__token_1013;
		__kaira__tokens->token_1015 = __kaira__token_1015;
		return __kaira__tokens;
	}
	return NULL;
}
void Transition_110::fire_phase2(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Binding *__kaira__binding)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	Tokens_110 *__kaira__tokens = static_cast<Tokens_110*>(__kaira__binding);
	ca::Token<std::vector<double> > *__kaira__token_1009 = __kaira__tokens->token_1009;
	ca::Token<int > *__kaira__token_1011 = __kaira__tokens->token_1011;
	ca::Token<std::vector<double> > *__kaira__token_1013 = __kaira__tokens->token_1013;
	ca::Token<DoubleMatrix > *__kaira__token_1015 = __kaira__tokens->token_1015;
	std::vector<double> &down = __kaira__token_1009->value;
	int &c = __kaira__token_1011->value;
	DoubleMatrix &data = __kaira__token_1015->value;
	std::vector<double> &up = __kaira__token_1013->value;
	__kaira__n->activate_transition_by_pos_id(2);
	Vars_110 __kaira__vars(c,ctx,data,down,up);
	transition_user_fn_110(ctx, __kaira__vars);
	__kaira__n->place_107.add(c+1);
	__kaira__n->activate_transition_by_pos_id(0);
	__kaira__n->activate_transition_by_pos_id(2);
	if (to_down(ctx) == __kaira__thread->get_process_id()) {
		__kaira__n->place_106.add(down);
		__kaira__n->activate_transition_by_pos_id(2);
} else {
	int __kaira__target = to_down(ctx);
		ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
		ca::pack(__kaira__packer, (down));
		__kaira__thread->send(__kaira__target, __kaira__n, 119, 1, __kaira__packer);
	}
	if (to_up(ctx) == __kaira__thread->get_process_id()) {
		__kaira__n->place_104.add(up);
		__kaira__n->activate_transition_by_pos_id(2);
} else {
	int __kaira__target = to_up(ctx);
		ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
		ca::pack(__kaira__packer, (up));
		__kaira__thread->send(__kaira__target, __kaira__n, 117, 1, __kaira__packer);
	}
	__kaira__n->place_105.add_token(__kaira__token_1015);
	__kaira__n->activate_transition_by_pos_id(0);
	__kaira__n->activate_transition_by_pos_id(2);
	__kaira__tokens->token_1015 = NULL;
	delete __kaira__binding;
}
bool Transition_110::is_enable(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_104.size() < 1) return false;
	if (__kaira__n->place_107.size() < 1) return false;
	if (__kaira__n->place_106.size() < 1) return false;
	if (__kaira__n->place_105.size() < 1) return false;
	// Inscription id=118 uid=1009 expr=down
	ca::Token < std::vector<double> > *__kaira__token_1009;
	__kaira__token_1009 = __kaira__n->place_104.begin();
	std::vector<double> &down = __kaira__token_1009->value;
	// Inscription id=118 uid=1011 expr=c
	ca::Token < int > *__kaira__token_1011;
	__kaira__token_1011 = __kaira__n->place_107.begin();
	int &c = __kaira__token_1011->value;
	// Inscription id=118 uid=1013 expr=up
	ca::Token < std::vector<double> > *__kaira__token_1013;
	__kaira__token_1013 = __kaira__n->place_106.begin();
	std::vector<double> &up = __kaira__token_1013->value;
	// Inscription id=118 uid=1015 expr=data
	ca::Token < DoubleMatrix > *__kaira__token_1015;
	__kaira__token_1015 = __kaira__n->place_105.begin();
	DoubleMatrix &data = __kaira__token_1015->value;
	if (!(c < param::LIMIT())) {
		return false;
	}
	{
		return true;
	}
	return false;
}
void Transition_110::pack_binding(ca::Packer &packer, ca::Binding *binding)
{
	Tokens_110 *tokens = static_cast<Tokens_110*>(binding);
	ca::pack(packer, tokens->token_1009->value);
	ca::pack(packer, tokens->token_1011->value);
	ca::pack(packer, tokens->token_1013->value);
	ca::pack(packer, tokens->token_1015->value);
}
ca::Binding* Transition_110::unpack_binding(ca::Unpacker &unpacker)
{
	Tokens_110 *tokens = new Tokens_110;
	tokens->token_1009 = new ca::Token<std::vector<double> >;
	ca::unpack(unpacker, tokens->token_1009->value);
	tokens->token_1011 = new ca::Token<int >;
	ca::unpack(unpacker, tokens->token_1011->value);
	tokens->token_1013 = new ca::Token<std::vector<double> >;
	ca::unpack(unpacker, tokens->token_1013->value);
	tokens->token_1015 = new ca::Token<DoubleMatrix >;
	ca::unpack(unpacker, tokens->token_1015->value);
	return tokens;
}
ca::FireResult Transition_110::full_fire_with_binding(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Packer &__kaira__packer)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_101 *__kaira__n = (Net_101*) __kaira__net;
	if (__kaira__n->place_104.size() < 1) return ca::NOT_ENABLED;
	if (__kaira__n->place_107.size() < 1) return ca::NOT_ENABLED;
	if (__kaira__n->place_106.size() < 1) return ca::NOT_ENABLED;
	if (__kaira__n->place_105.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=118 uid=1009 expr=down
	ca::Token < std::vector<double> > *__kaira__token_1009;
	__kaira__token_1009 = __kaira__n->place_104.begin();
	std::vector<double> &down = __kaira__token_1009->value;
	// Inscription id=118 uid=1011 expr=c
	ca::Token < int > *__kaira__token_1011;
	__kaira__token_1011 = __kaira__n->place_107.begin();
	int &c = __kaira__token_1011->value;
	// Inscription id=118 uid=1013 expr=up
	ca::Token < std::vector<double> > *__kaira__token_1013;
	__kaira__token_1013 = __kaira__n->place_106.begin();
	std::vector<double> &up = __kaira__token_1013->value;
	// Inscription id=118 uid=1015 expr=data
	ca::Token < DoubleMatrix > *__kaira__token_1015;
	__kaira__token_1015 = __kaira__n->place_105.begin();
	DoubleMatrix &data = __kaira__token_1015->value;
	if (!(c < param::LIMIT())) {
		return ca::NOT_ENABLED;
	}
	{
		ca::pack(__kaira__packer, __kaira__token_1009->value);
		ca::pack(__kaira__packer, __kaira__token_1011->value);
		ca::pack(__kaira__packer, __kaira__token_1013->value);
		ca::pack(__kaira__packer, __kaira__token_1015->value);
		{
			__kaira__n->place_104.remove(__kaira__token_1009);
			__kaira__n->place_107.remove(__kaira__token_1011);
			__kaira__n->place_106.remove(__kaira__token_1013);
			__kaira__n->place_105.remove(__kaira__token_1015);
		}
		__kaira__n->activate_transition_by_pos_id(2);
		Vars_110 __kaira__vars(c,ctx,data,down,up);
		transition_user_fn_110(ctx, __kaira__vars);
		__kaira__n->place_107.add(c+1);
		__kaira__n->activate_transition_by_pos_id(0);
		__kaira__n->activate_transition_by_pos_id(2);
		if (to_down(ctx) == __kaira__thread->get_process_id()) {
			__kaira__n->place_106.add(down);
			__kaira__n->activate_transition_by_pos_id(2);
		} else {
			int __kaira__target = to_down(ctx);
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (down));
				__kaira__thread->send(__kaira__target, __kaira__n, 119, 1, __kaira__packer);
			}
			if (to_up(ctx) == __kaira__thread->get_process_id()) {
				__kaira__n->place_104.add(up);
				__kaira__n->activate_transition_by_pos_id(2);
		} else {
			int __kaira__target = to_up(ctx);
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (up));
				__kaira__thread->send(__kaira__target, __kaira__n, 117, 1, __kaira__packer);
			}
			__kaira__n->place_105.add_token(__kaira__token_1015);
			__kaira__n->activate_transition_by_pos_id(0);
			__kaira__n->activate_transition_by_pos_id(2);
			delete __kaira__token_1009;
			delete __kaira__token_1011;
			delete __kaira__token_1013;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
class VerifConfiguration : public cass::VerifConfiguration {
public:
VerifConfiguration()
{
	int transitions[] = {111};
	for (int i = 0; i < 1; i++)
	{
		ignored_transitions.insert(transitions[i]);
	}
}
bool is_dependent(const cass::Action &a1, const cass::Action &a2, const std::vector<int> &marking)
{
	cass::VerifThread thread(a1.process);
	ca::Context ctx(&thread, NULL);
	if (a1.type == cass::ActionFire && a2.type == cass::ActionFire) {
	}
	if (a1.process != a2.process) {
		return false;
	}
	if (a1.type == cass::ActionFire && a2.type == cass::ActionFire) {
		if (a1.data.fire.transition_def->get_id() == a2.data.fire.transition_def->get_id()) {
			fprintf(stderr, "Internal error - The same transitions in POR.\n");
			abort();
		}
		switch (a1.data.fire.transition_def->get_id()) {
			case 111:
			{
				switch (a2.data.fire.transition_def->get_id()) {
					case 112:
					{
						return false;
						break;
					}

					case 110:
					{
						return true; // Transitions taking tokens from the same input place
						break;
					}

					default:
					fprintf(stderr, "Internal error");
					abort();
				}
				break;
			}

			case 112:
			{
				switch (a2.data.fire.transition_def->get_id()) {
					case 111:
					{
						return false;
						break;
					}

					case 110:
					{
						return false;
						break;
					}

					default:
					fprintf(stderr, "Internal error");
					abort();
				}
				break;
			}

			case 110:
			{
				switch (a2.data.fire.transition_def->get_id()) {
					case 111:
					{
						return true; // Transitions taking tokens from the same input place
						break;
					}

					case 112:
					{
						return false;
						break;
					}

					default:
					fprintf(stderr, "Internal error");
					abort();
				}
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
	}
	if (a1.type == cass::ActionFire && a2.type == cass::ActionReceive) {
		switch (a2.data.receive.edge_id) {
			case 125:
			{
				// t 111 --> p 108
				int edge_priority = 0;
				if (is_enabled(112, a1.process, marking, 108)) edge_priority = 0;
				if (edge_priority > 0 && 111 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 112 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 110 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 127:
			{
				// t 110 --> p 107
				int edge_priority = 0;
				if (is_enabled(111, a1.process, marking, 107)) edge_priority = 0;
				if (is_enabled(110, a1.process, marking, 107)) edge_priority = 0;
				if (edge_priority > 0 && 111 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 112 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 110 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 119:
			{
				// t 110 --> p 106
				int edge_priority = 0;
				if (is_enabled(110, a1.process, marking, 106)) edge_priority = 0;
				if (edge_priority > 0 && 111 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 112 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 110 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 117:
			{
				// t 110 --> p 104
				int edge_priority = 0;
				if (is_enabled(110, a1.process, marking, 104)) edge_priority = 0;
				if (edge_priority > 0 && 111 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 112 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 110 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 118:
			{
				// t 110 --> p 105
				int edge_priority = 0;
				if (is_enabled(111, a1.process, marking, 105)) edge_priority = 0;
				if (is_enabled(110, a1.process, marking, 105)) edge_priority = 0;
				if (edge_priority > 0 && 111 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 112 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 110 == a1.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
		switch (a1.data.fire.transition_def->get_id()) {
			case 111:
			{
				// t 111 --> p 108
				if (a2.data.receive.edge_id == 125) {
					return true;
				}
				return false;
				break;
			}

			case 112:
			{
				return false;
				break;
			}

			case 110:
			{
				// t 110 --> p 107
				if (a2.data.receive.edge_id == 127) {
					return true;
				}
				// t 110 --> p 106
				if (a2.data.receive.edge_id == 119) {
					if (a1.process != (to_down(ctx))) {
						return false;
					}
					return true;
				}
				// t 110 --> p 104
				if (a2.data.receive.edge_id == 117) {
					if (a1.process != (to_up(ctx))) {
						return false;
					}
					return true;
				}
				// t 110 --> p 105
				if (a2.data.receive.edge_id == 118) {
					return true;
				}
				return false;
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
	}
	if (a1.type == cass::ActionReceive && a2.type == cass::ActionFire) {
		switch (a1.data.receive.edge_id) {
			case 125:
			{
				// t 111 --> p 108
				int edge_priority = 0;
				if (is_enabled(112, a1.process, marking, 108)) edge_priority = 0;
				if (edge_priority > 0 && 111 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 112 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 110 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 127:
			{
				// t 110 --> p 107
				int edge_priority = 0;
				if (is_enabled(111, a1.process, marking, 107)) edge_priority = 0;
				if (is_enabled(110, a1.process, marking, 107)) edge_priority = 0;
				if (edge_priority > 0 && 111 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 112 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 110 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 119:
			{
				// t 110 --> p 106
				int edge_priority = 0;
				if (is_enabled(110, a1.process, marking, 106)) edge_priority = 0;
				if (edge_priority > 0 && 111 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 112 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 110 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 117:
			{
				// t 110 --> p 104
				int edge_priority = 0;
				if (is_enabled(110, a1.process, marking, 104)) edge_priority = 0;
				if (edge_priority > 0 && 111 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 112 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 110 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			case 118:
			{
				// t 110 --> p 105
				int edge_priority = 0;
				if (is_enabled(111, a1.process, marking, 105)) edge_priority = 0;
				if (is_enabled(110, a1.process, marking, 105)) edge_priority = 0;
				if (edge_priority > 0 && 111 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 112 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				if (edge_priority > 0 && 110 == a2.data.fire.transition_def->get_id()) {
					return true;
				}
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
		switch (a2.data.fire.transition_def->get_id()) {
			case 111:
			{
				// t 111 --> p 108
				if (a1.data.receive.edge_id == 125) {
					return true;
				}
				return false;
				break;
			}

			case 112:
			{
				return false;
				break;
			}

			case 110:
			{
				// t 110 --> p 107
				if (a1.data.receive.edge_id == 127) {
					return true;
				}
				// t 110 --> p 106
				if (a1.data.receive.edge_id == 119) {
					if (a1.process != (to_down(ctx))) {
						return false;
					}
					return true;
				}
				// t 110 --> p 104
				if (a1.data.receive.edge_id == 117) {
					if (a1.process != (to_up(ctx))) {
						return false;
					}
					return true;
				}
				// t 110 --> p 105
				if (a1.data.receive.edge_id == 118) {
					return true;
				}
				return false;
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
	}
	if (a1.type == cass::ActionReceive && a2.type == cass::ActionReceive) {
		if (a1.data.receive.edge_id == a2.data.receive.edge_id &&a1.data.receive.source == a2.data.receive.source) {
			fprintf(stderr, "Internal error - The same receive actions in POR");
			abort();
		}
		switch (a1.data.receive.edge_id) {
			case 119: // t 110 --> p 106
			return false;
			case 117: // t 110 --> p 104
			return false;
			default: return false;
		}
	}
}
bool is_visible(const cass::Action &action)
{
	if (action.type == cass::ActionFire) {
	}
	return false;
}
bool compare(const cass::Arc &arc1, const cass::Arc &arc2)
{
	if (arc1.nni->data.fire.transition_id == arc2.nni->data.fire.transition_id) {
		switch (arc1.nni->data.fire.transition_id) {
			case 112:
			{
				return arc1.nni->data.fire.process_id < arc2.nni->data.fire.process_id;
			}
			case 110:
			{
				if (arc1.nni->data.fire.process_id == arc2.nni->data.fire.process_id) {
					return memcmp(arc1.nni->data.fire.binding, arc2.nni->data.fire.binding, mhash_get_block_size(MHASH_MD5)) < 0;
				} else {
					return arc1.nni->data.fire.process_id < arc2.nni->data.fire.process_id;
				}
			}
		}
	} else {
		return arc1.nni->data.fire.transition_id < arc2.nni->data.fire.transition_id;
	}
}
void compute_successors(const cass::Action &a,std::deque<cass::Action> &queue,cass::ActionSet &processed,const std::vector<bool> &receive_blocked,const std::vector<int> &enabled_priorities,std::vector<int> &marking,const cass::ActionSet &ample)
{
	cass::Action action;
	cass::VerifThread thread(a.process);
	ca::Context ctx(&thread, NULL);
	switch (a.type) {
		case cass::ActionFire:
		switch (a.data.fire.transition_def->get_id()) {
			case 111:
			{
				// a collective transition synchronizes all process
				for (int __kaira__i = 0; __kaira__i < ca::process_count; __kaira__i++) {
					if (__kaira__i == a.process) continue;
					cass::Action __kaira__tmp = a;
					__kaira__tmp.process = __kaira__i;
					if (processed.find(__kaira__tmp) == processed.end() || ample.find(__kaira__tmp) != ample.end()) {
						return;
					}
				}
				// if all transitions were fired we have to add successors for all process 
				for (int __kaira__cp = 0; __kaira__cp < ca::process_count; __kaira__cp++) {
					cass::Action __kaira__a = a;
					__kaira__a.process = __kaira__cp;
					// place 108
					// there is 5 places, place 108 is on position 4.
					marking[5 * __kaira__a.process + 4]++;
					if (is_enabled(112, __kaira__a.process, marking, -1)) {
						action.type = cass::ActionFire;
						action.process = __kaira__a.process;
						action.data.fire.transition_def = &transition_112;
						if (enabled_priorities[action.process] <= transition_112.get_priority() && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
				}
				return;
				break;
			}

			case 112:
			{
				const cass::Action &__kaira__a = a;
				return;
				break;
			}

			case 110:
			{
				const cass::Action &__kaira__a = a;
				// place 107
				// there is 5 places, place 107 is on position 3.
				marking[5 * __kaira__a.process + 3]++;
				if (is_enabled(111, __kaira__a.process, marking, -1)) {
					action.type = cass::ActionFire;
					action.process = __kaira__a.process;
					action.data.fire.transition_def = &transition_111;
					if (enabled_priorities[action.process] <= transition_111.get_priority() && processed.find(action) == processed.end()) {
						queue.push_back(action);
						processed.insert(action);
					}
				}
				// place 106
				{
					int __kaira__target = to_down(ctx);
					if (__kaira__a.process == __kaira__target) {
						// there is 5 places, place 106 is on position 2.
						marking[5 * __kaira__a.process + 2]++;
					} else {
						action.type = cass::ActionReceive;
						action.process = __kaira__target;
						action.data.receive.source = a.process;
						action.data.receive.edge_id = 119;
						if (!receive_blocked[action.process * ca::process_count + __kaira__a.process] && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
				}
				// place 104
				{
					int __kaira__target = to_up(ctx);
					if (__kaira__a.process == __kaira__target) {
						// there is 5 places, place 104 is on position 0.
						marking[5 * __kaira__a.process + 0]++;
					} else {
						action.type = cass::ActionReceive;
						action.process = __kaira__target;
						action.data.receive.source = a.process;
						action.data.receive.edge_id = 117;
						if (!receive_blocked[action.process * ca::process_count + __kaira__a.process] && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
				}
				// place 105
				// there is 5 places, place 105 is on position 1.
				marking[5 * __kaira__a.process + 1]++;
				if (is_enabled(111, __kaira__a.process, marking, -1)) {
					action.type = cass::ActionFire;
					action.process = __kaira__a.process;
					action.data.fire.transition_def = &transition_111;
					if (enabled_priorities[action.process] <= transition_111.get_priority() && processed.find(action) == processed.end()) {
						queue.push_back(action);
						processed.insert(action);
					}
				}
				return;
				break;
			}

			default:
			fprintf(stderr, "Internal error");
			abort();
		}
		case cass::ActionReceive:
		{
			switch (a.data.receive.edge_id) {
				case 119: // t 110 --> p 106
				{
					const cass::Action &__kaira__a = a;
					// there is 5 places, place 106 is on position 2.
					marking[5 * __kaira__a.process + 2]++;
					if (is_enabled(110, __kaira__a.process, marking, -1)) {
						action.type = cass::ActionFire;
						action.process = __kaira__a.process;
						action.data.fire.transition_def = &transition_110;
						if (enabled_priorities[action.process] <= transition_110.get_priority() && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
					return;
				}
				case 117: // t 110 --> p 104
				{
					const cass::Action &__kaira__a = a;
					// there is 5 places, place 104 is on position 0.
					marking[5 * __kaira__a.process + 0]++;
					if (is_enabled(110, __kaira__a.process, marking, -1)) {
						action.type = cass::ActionFire;
						action.process = __kaira__a.process;
						action.data.fire.transition_def = &transition_110;
						if (enabled_priorities[action.process] <= transition_110.get_priority() && processed.find(action) == processed.end()) {
							queue.push_back(action);
							processed.insert(action);
						}
					}
					return;
				}
			}
			return;
		}
	}
}
std::vector<int> get_marking(cass::State *s) {
	std::vector<int> marking;
	marking.resize(5 * ca::process_count);
	for (int p = 0; p < ca::process_count; p++) {
		Net_101 *n = (Net_101 *) s->get_net(p);
		marking[p * 5 + 0] = n->get_token_count_in_place(104);
		marking[p * 5 + 1] = n->get_token_count_in_place(105);
		marking[p * 5 + 2] = n->get_token_count_in_place(106);
		marking[p * 5 + 3] = n->get_token_count_in_place(107);
		marking[p * 5 + 4] = n->get_token_count_in_place(108);
	}
	return marking;
}
bool is_enabled(int transition_id, int process_id, const std::vector<int> &marking, int ignored_place) {
	switch (transition_id) {
		case 111:
		{
			if (marking[5 * process_id + 3] == 0 && 107 != ignored_place) return false;
			if (marking[5 * process_id + 1] == 0 && 105 != ignored_place) return false;
			break;
		}

		case 112:
		{
			if (marking[5 * process_id + 4] == 0 && 108 != ignored_place) return false;
			break;
		}

		case 110:
		{
			if (marking[5 * process_id + 0] == 0 && 104 != ignored_place) return false;
			if (marking[5 * process_id + 3] == 0 && 107 != ignored_place) return false;
			if (marking[5 * process_id + 2] == 0 && 106 != ignored_place) return false;
			if (marking[5 * process_id + 1] == 0 && 105 != ignored_place) return false;
			break;
		}

		default:
		fprintf(stderr, "Internal error");
		abort();
	}
	return true;
}
void pack_final_marking(ca::NetBase *net, ca::Packer &packer)
{
	Net_101 *n = (Net_101 *) net;
}
};
int main(int argc, char **argv)
{
	ca::project_description("<project library-octave=\"False\" library-rpc=\"False\" target_env=\"C++\"><configuration><parameter default=\"10\" description=\"\" name=\"LIMIT\" policy=\"mandatory\" type=\"int\" /><parameter default=\"4\" description=\"\" name=\"SIZE_X\" policy=\"mandatory\" type=\"int\" /><parameter default=\"4\" description=\"\" name=\"SIZE_Y\" policy=\"mandatory\" type=\"int\" /><parameter default=\"200\" description=\"\" name=\"TEMP\" policy=\"mandatory\" type=\"int\" /><build-option name=\"LIBS\" /><build-option name=\"OTHER_FILES\">compute.cpp</build-option><build-option name=\"CFLAGS\">-O0 -g</build-option><head-code>\n#include &lt;compute.h&gt;\n\nnamespace ca {\n\n\tCA_TOKEN_NAME(DoubleMatrix, m) {\n\t\treturn \"DoubleMatrix\";\n\t}\n\t\n\tCA_PACK(DoubleMatrix, packer, m) {\n\t\tpacker &lt;&lt; m.get_size_x() &lt;&lt; m.get_size_y();\n\t\tpack(packer, m.get_data(), m.get_data_size());\n\t}\n\t\n\tCA_UNPACK(DoubleMatrix, unpacker, m) {\n\t\tint size_x, size_y;\n\t\tunpacker &gt;&gt; size_x &gt;&gt; size_y;\n\t\tm.setup(size_x, size_y);\n\t\tm.set_data((double*) unpacker.unpack_data(m.get_data_size()));\n\t\tm.swap();\t\t\n\t}\t\t\n}\n\nint to_down(ca::Context &amp;ctx)\n{\n\treturn (ctx.process_id() + 1) % ctx.process_count();\n}\n\nint to_up(ca::Context &amp;ctx)\n{\n\treturn (ctx.process_id() + ctx.process_count() - 1) \n\t\t\t% ctx.process_count();\n}</head-code></configuration><net id=\"101\" name=\"Main\"><area id=\"102\" sx=\"490\" sy=\"280\" x=\"211\" y=\"143\"><init x=\"211\" y=\"128\">ctx.all_processes()</init></area><place id=\"104\" label-x=\"279\" label-y=\"359\" name=\"Down row\" radius=\"20\" sx=\"33\" sy=\"0\" x=\"279\" y=\"359\"><place-type x=\"308\" y=\"381\">std::vector&lt;double&gt;</place-type><init x=\"296\" y=\"329\" /><code>\tstd::vector&lt;double&gt; row(param::SIZE_X(), 0);\n\tplace.add(row);\n</code><trace trace-tokens=\"False\" /></place><place id=\"105\" label-x=\"280\" label-y=\"286\" name=\"Local data\" radius=\"20\" sx=\"33\" sy=\"0\" x=\"280\" y=\"286\"><place-type x=\"318\" y=\"312\">DoubleMatrix</place-type><init x=\"297\" y=\"256\" /><code>\tint id = ctx.process_id();\n\tint size = ctx.process_count();\n\tint position = id_to_position(param::SIZE_Y(), size, id);\n\tDoubleMatrix matrix(param::SIZE_X(), id_to_size(param::SIZE_Y(), size, id));\n\tset_fixed_temp(matrix, param::SIZE_Y(), position, param::TEMP());\n\tmatrix.swap();\n\tplace.add(matrix);\n</code><trace trace-tokens=\"False\" /></place><place id=\"106\" label-x=\"281\" label-y=\"208\" name=\"Up row\" radius=\"20\" sx=\"31\" sy=\"0\" x=\"281\" y=\"208\"><place-type x=\"330\" y=\"228\">std::vector&lt;double&gt;</place-type><init x=\"298\" y=\"178\" /><code>\tstd::vector&lt;double&gt; row(param::SIZE_X(), 0);\n\tplace.add(row);\n</code><trace trace-tokens=\"False\" /></place><place id=\"107\" label-x=\"647\" label-y=\"383\" name=\"Counter\" radius=\"20\" sx=\"16\" sy=\"0\" x=\"647\" y=\"383\"><place-type x=\"677\" y=\"406\">int</place-type><init x=\"683\" y=\"353\">[0]</init><trace trace-tokens=\"False\" /></place><place id=\"108\" label-x=\"800\" label-y=\"287\" name=\"\" radius=\"22\" sx=\"0\" sy=\"0\" x=\"800\" y=\"287\"><place-type x=\"817\" y=\"304\">std::vector&lt;DoubleMatrix&gt;</place-type><init x=\"817\" y=\"257\" /><trace trace-tokens=\"False\" /></place><transition clock=\"False\" collective=\"True\" id=\"111\" label-x=\"653\" label-y=\"288\" name=\"Send &#10;results\" priority=\"\" sx=\"70\" sy=\"35\" x=\"618\" y=\"270\"><guard x=\"618\" y=\"250\" /><trace>fire</trace><root x=\"670\" y=\"310\">0</root></transition><transition clock=\"False\" collective=\"False\" id=\"112\" label-x=\"784\" label-y=\"206\" name=\"Write results\" priority=\"\" sx=\"100\" sy=\"42\" x=\"749\" y=\"188\"><guard x=\"749\" y=\"168\" /><code>\tconst int size = var.results.size();\n\tDoubleMatrix out(param::SIZE_X(), param::SIZE_Y());\n\n\tfor (int i = 0; i &lt; var.results.size(); i++) {\n\t\tint position = id_to_position(param::SIZE_Y(), size, i);\n\t\tint y = id_to_size(param::SIZE_Y(), size, i);\n\t\tmemcpy(out.get_write_pointer(0, position),\n\t\t       var.results[i].get_data(), var.results[i].get_data_size());\n\t}\n\tout.swap();\n\tout.write_to_file(\"results.html\");\n\tctx.quit();\n</code><trace>fire</trace><verif-occurrence binding=\"False\" process=\"True\" /></transition><transition clock=\"False\" collective=\"False\" id=\"110\" label-x=\"546\" label-y=\"288\" name=\"Compute\" priority=\"\" sx=\"70\" sy=\"35\" x=\"511\" y=\"270\"><guard x=\"534\" y=\"252\">c &lt; param::LIMIT()</guard><code>\tcompute_new_values(var.data, &amp;var.up[0], &amp;var.down[0]);\n\tint position = id_to_position(param::SIZE_Y(), ctx.process_count(), ctx.process_id());\n\tset_fixed_temp(var.data, param::SIZE_Y(), position, param::TEMP());\n\tvar.data.swap();\n</code><trace>fire</trace><verif-occurrence binding=\"True\" process=\"True\" /></transition><edge from_item=\"108\" id=\"123\" to_item=\"112\"><inscription x=\"813.0\" y=\"244.0\">results</inscription></edge><edge from_item=\"107\" id=\"124\" to_item=\"111\"><inscription x=\"661.0\" y=\"331.0\">param::LIMIT()</inscription></edge><edge from_item=\"111\" id=\"125\" to_item=\"108\"><inscription x=\"705.0\" y=\"268.0\">[gather] data</inscription></edge><edge from_item=\"105\" id=\"126\" to_item=\"111\"><inscription x=\"444.0\" y=\"161.0\">data</inscription><point x=\"243\" y=\"286\" /><point x=\"242\" y=\"177\" /><point x=\"654\" y=\"180\" /></edge><edge from_item=\"104\" id=\"129\" to_item=\"110\"><inscription x=\"427.0\" y=\"325.0\">down</inscription></edge><edge from_item=\"110\" id=\"127\" to_item=\"107\"><inscription x=\"556.0\" y=\"360.0\">c+1</inscription><point x=\"580\" y=\"350\" /></edge><edge from_item=\"107\" id=\"122\" to_item=\"110\"><inscription x=\"610.0\" y=\"327.0\">c</inscription></edge><edge from_item=\"106\" id=\"121\" to_item=\"110\"><inscription x=\"412.0\" y=\"249.0\">up</inscription><point x=\"328\" y=\"245\" /></edge><edge from_item=\"110\" id=\"119\" to_item=\"106\"><inscription x=\"386.0\" y=\"194.0\">down@to_down(ctx)</inscription><point x=\"498\" y=\"210\" /></edge><edge bidirectional=\"true\" from_item=\"105\" id=\"118\" to_item=\"110\"><inscription x=\"408.0\" y=\"291.0\">data</inscription><point x=\"380\" y=\"285\" /></edge><edge from_item=\"110\" id=\"117\" to_item=\"104\"><inscription x=\"427.0\" y=\"365.0\">up@to_up(ctx)</inscription><point x=\"516\" y=\"360\" /></edge></net></project>");
	std::vector<ca::Parameter*> parameters;
	parameters.push_back(&param::SIZE_X);
	parameters.push_back(&param::LIMIT);
	parameters.push_back(&param::SIZE_Y);
	parameters.push_back(&param::TEMP);

	cass::init(argc, argv, parameters, false);

	ca::NetDef *def_101 = new ca::NetDef(0, 101, spawn_101);
	def_101->register_transition(&transition_111);
	def_101->register_transition(&transition_112);
	def_101->register_transition(&transition_110);
	ca::NetDef *defs[] = {def_101};
	ca::setup(1, defs, false);
	VerifConfiguration verif_configuration;
	cass::Core core(argc, argv, verif_configuration, parameters);
	core.generate();
	core.postprocess();
	return 0;
}
#line 1 "*112/function"
void transition_user_fn_112(ca::Context &ctx, Vars_112 &var)
{
	const int size = var.results.size();
	DoubleMatrix out(param::SIZE_X(), param::SIZE_Y());

	for (int i = 0; i < var.results.size(); i++) {
		int position = id_to_position(param::SIZE_Y(), size, i);
		int y = id_to_size(param::SIZE_Y(), size, i);
		memcpy(out.get_write_pointer(0, position),
		       var.results[i].get_data(), var.results[i].get_data_size());
	}
	out.swap();
	out.write_to_file("results.html");
	ctx.quit();
}
#line 1 "*110/function"
void transition_user_fn_110(ca::Context &ctx, Vars_110 &var)
{
	compute_new_values(var.data, &var.up[0], &var.down[0]);
	int position = id_to_position(param::SIZE_Y(), ctx.process_count(), ctx.process_id());
	set_fixed_temp(var.data, param::SIZE_Y(), position, param::TEMP());
	var.data.swap();
}
#line 1 "*104/init_function"
void place_user_fn_104(ca::Context &ctx, ca::TokenList<std::vector<double> > &place)
{
	std::vector<double> row(param::SIZE_X(), 0);
	place.add(row);
}
#line 1 "*105/init_function"
void place_user_fn_105(ca::Context &ctx, ca::TokenList<DoubleMatrix > &place)
{
	int id = ctx.process_id();
	int size = ctx.process_count();
	int position = id_to_position(param::SIZE_Y(), size, id);
	DoubleMatrix matrix(param::SIZE_X(), id_to_size(param::SIZE_Y(), size, id));
	set_fixed_temp(matrix, param::SIZE_Y(), position, param::TEMP());
	matrix.swap();
	place.add(matrix);
}
#line 1 "*106/init_function"
void place_user_fn_106(ca::Context &ctx, ca::TokenList<std::vector<double> > &place)
{
	std::vector<double> row(param::SIZE_X(), 0);
	place.add(row);
}
